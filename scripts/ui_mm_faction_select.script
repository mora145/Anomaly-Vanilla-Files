-- =======================================================================================
-- Remade by Tronex
-- Last modification: 2019/5/18

-- New Game menu (Fresh Start)
-- Inventory simulator
-- Ironman mode save killer
-- Setting up new games
-- Support for warfare
-- ISG and Mercs will be enemies on Story mode
-- =======================================================================================


--=======================================< Controls >=======================================--
local ini_ico = ini_file("plugins\\player_icons.ltx")
local ini_itm = ini_file("items\\settings\\new_game_loadouts.ltx")
local ini_map = ini_file("plugins\\new_game_start_locations.ltx")
local ini_opt = ini_file("plugins\\new_game_options.ltx")
local ini_diff = ini_file("plugins\\difficulty.ltx")
local gs
local mf,mc,sf,uc
local clr_g,clr_y,clr_o,clr_r,clr_b,clr_b1,clr_b2,clr_p,clr_gr

local faction_psi_off = {
	["monolith"] = true,
	["greh"] = true,
	["zombied"] = true,
}

local faction_no_story = {
	["zombied"] = true,
	--["renegade"] = true,
	--["greh"] = true,
	--["isg"] = true,
}

local faction_limited_playthrough = {
	["isg"] = true,
}

--=======================================< Callbacks >=======================================--
local spawn_path, start_pos, saved_bolt
local function on_game_load(binder)
	local config = axr_main.config
	if not (config) then
		return
	end

	local se_actor = alife():actor()
	local need_save
	
	-- Gameplay Options
	if (USE_MARSHAL) then
		if (config:r_value("character_creation","new_game_hardcore_mode",1) == true) then
			-- shitty way to make a uuid but should be good enough to track the same saves
			local ironman = {}
			ironman.uuid = GAME_VERSION .. "_" .. tostring(math.random(100)) .. tostring(math.random()) .. tostring(math.random(1000))
			ironman.death_limit = config:r_value("character_creation","new_game_hardcore_mode_lives",2) or 1
			ironman.life_feature = config:r_value("character_creation","new_game_hardcore_mode_regenerate",2) and true or false
			ironman.life_cycle = config:r_value("character_creation","new_game_hardcore_mode_regenerate",2) or 120
			ironman.death_count = 0
			ironman.granted_lives = 0
			ironman.sleep_hrs = 0
			alife_storage_manager.get_state().ironman = ironman
			
			config:w_value("character_creation","new_game_hardcore_mode")
			config:w_value("character_creation","new_game_hardcore_mode_lives")
			config:w_value("character_creation","new_game_hardcore_mode_regenerate")
			need_save = true
			
			printdbg("- Ironman mode | Enabled")
		end
		if (config:r_value("character_creation","new_game_survival_mode",1) == true) then
			alife_storage_manager.get_state().enable_survival_mode = true
			config:w_value("character_creation","new_game_survival_mode")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_azazel_mode",1) == true) then
			alife_storage_manager.get_state().enable_azazel_mode = true
			alife_storage_manager.get_state().opened_routes = true
			config:w_value("character_creation","new_game_azazel_mode")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_warfare",1) == true) then
			alife_storage_manager.get_state().enable_warfare_mode = true
			config:w_value("character_creation","new_game_warfare")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_campfire_mode",1) == true) then
			alife_storage_manager.get_state().enable_campfire_mode = true
			config:w_value("character_creation","new_game_campfire_mode")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_conditions_mode",1) == true) then
			alife_storage_manager.get_state().enable_conditions_mode = true
			config:w_value("character_creation","new_game_conditions_mode")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_timer_mode",2)) then
			alife_storage_manager.get_state().enable_timer_mode = config:r_value("character_creation","new_game_timer_mode",2)
			config:w_value("character_creation","new_game_timer_mode")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_opened_routes",1) == true) then
			alife_storage_manager.get_state().opened_routes = true
			config:w_value("character_creation","new_game_opened_routes")
			need_save = true
		end
		
		-- Gameplay
		if (config:r_value("character_creation","new_game_difficulty",2)) then
			local difficulty = {}
			local diff = config:r_value("character_creation","new_game_difficulty",2)
			
			difficulty["type"]               	= diff
			
			difficulty["actor_immunities"] 	 	= ini_diff:r_float_ex("gdiff_" .. diff , "actor_immunities") or 1
			difficulty["power_loss_bias"] 		= ini_diff:r_float_ex("gdiff_" .. diff , "power_loss_bias") or 0.2
			difficulty["weight"]	            = ini_diff:r_float_ex("gdiff_" .. diff , "max_weight") or 60
			difficulty["thirst"] 				= ini_diff:r_bool_ex("gdiff_" .. diff , "thirst") or false
			difficulty["sleep"] 				= ini_diff:r_bool_ex("gdiff_" .. diff , "sleep") or false
			difficulty["radiation_day"]			= ini_diff:r_bool_ex("gdiff_" .. diff , "radiation_day") or false
			
			alife_storage_manager.get_state().diff_game = difficulty
			
			config:w_value("character_creation","new_game_difficulty")
			need_save = true
		end
	
		-- Economy
		if (config:r_value("character_creation","new_game_economy",2)) then
			local economy = {}
			local eco = config:r_value("character_creation","new_game_economy",2)
			
			economy["type"]               	= eco
			
			economy["goodwill"]           	= ini_diff:r_float_ex("econ_" .. eco , "goodwill") or 1
			economy["rewards"]            	= ini_diff:r_float_ex("econ_" .. eco , "rewards") or 1
			economy["repair"]             	= ini_diff:r_float_ex("econ_" .. eco , "repair") or 1
			economy["upgrade"]            	= ini_diff:r_float_ex("econ_" .. eco , "upgrade") or 1
			economy["buy"]                	= ini_diff:r_float_ex("econ_" .. eco , "buy") or 1
			economy["sell"]               	= ini_diff:r_float_ex("econ_" .. eco , "sell") or 1
			economy["artefact"]           	= ini_diff:r_float_ex("econ_" .. eco , "artefact") or 1
			economy["loots"]              	= ini_diff:r_float_ex("econ_" .. eco , "loots") or 1
			economy["money_loots"]        	= ini_diff:r_float_ex("econ_" .. eco , "money_loots") or 1
			economy["stash_chance"]			= ini_diff:r_float_ex("econ_" .. eco , "stash_chance") or 0.4
			economy["weapon_degradation"] 	= ini_diff:r_float_ex("econ_" .. eco , "weapon_degradation") or 1
			economy["battery_consumption"] 	= ini_diff:r_float_ex("econ_" .. eco , "battery_consumption") or 1
			economy["random_items"] 		= ini_diff:r_float_ex("econ_" .. eco , "random_items") or 0.5
			economy["scope_chance"] 		= ini_diff:r_float_ex("econ_" .. eco , "scope_chance") or 0.15
			economy["restock"] 				= ini_diff:r_float_ex("econ_" .. eco , "restock") or 24
			economy["percentage_parts"]		= ini_diff:r_bool_ex("econ_" .. eco , "percentage_parts") or false
			economy["limited_bolts"] 		= ini_diff:r_bool_ex("econ_" .. eco , "limited_bolts") or false
			economy["arty_degradation"] 	= ini_diff:r_bool_ex("econ_" .. eco , "arty_degradation") or false
			economy["bkpk_degradation"] 	= ini_diff:r_bool_ex("econ_" .. eco , "bkpk_degradation") or false

			alife_storage_manager.get_state().diff_eco = economy
			
			config:w_value("character_creation","new_game_economy")
			need_save = true
		end
	end
	
	-- Name
	local new_character_name = config:r_value("character_creation","new_game_character_name",3) or ""
	if (new_character_name and new_character_name ~= "") then
		config:w_value("character_creation","new_game_character_name")
		need_save = true
		
		new_character_name = new_character_name:gsub("_"," ")
		
		se_actor:set_character_name(new_character_name)
	end
	
	-- Icon
	local new_character_icon = config:r_value("character_creation","new_game_icon",3)
	if (new_character_icon and new_character_icon ~= "") then
		db.actor_binder.character_icon = new_character_icon
		
		config:w_value("character_creation","new_game_icon")
		need_save = true
	end
	
	-- Faction
	local faction = config:r_value("character_creation","new_game_faction",3) or ""


	if (faction and faction ~= "") then
		config:w_value("character_creation","new_game_faction")
		need_save = true
		
		-- Faction Spawn Position
		local start_location = config:r_value("character_creation","new_game_map")
		config:w_value("character_creation","new_game_map")
		
		if start_location and start_location ~= "" then
			start_pos = {}
			table.insert(start_pos,ini_map:r_float_ex(start_location, "lvid"))
			table.insert(start_pos,ini_map:r_float_ex(start_location, "gvid"))
			table.insert(start_pos,vector():set(ini_map:r_float_ex(start_location,"x"),ini_map:r_float_ex(start_location,"y"),ini_map:r_float_ex(start_location,"z")))
		else
			spawn_path = nil  --patrol("spawn_player_"..faction)
		end
		
		-- Enable the story quests + Drx questlines, or disable their components depending on player choice and faction.
		if (config:r_value("character_creation","new_game_story_mode",1) == true) and (not has_alife_info("story_mode_disabled")) then
			if faction_psi_off[faction] then
				-- Turn off the Miracle Machine:
				give_info("yan_labx16_switcher_1_off")
				give_info("yan_labx16_switcher_2_off")
				give_info("yan_labx16_switcher_3_off")
				give_info("yan_labx16_switcher_primary_off")
	
				-- Turn off the Brain Scorcher:
				give_info("bar_deactivate_radar_done")
	
				-- Turn off the Generators:
				give_info("warlab_deactivate_generators_done")
			end
			
			-- Allow Sin squads to spawn if player is Sinner or Monolith
			if (faction == "greh") or (faction == "monolith") then
				give_info("mortal_sin")
			end
			
			-- Allow ISG squads to spawn if player is ISG
			if (faction == "isg") then
				give_info("isg_entered_the_zone")
			end
			
			-- For story mode, Mercs and ISG will be enemies
			if (faction ~= "isg") then
				local fac_1 = {"killer","actor_killer"}
				local fac_2 = {"isg","actor_isg"}
				for i=1,2 do
					for j=1,2 do
						game_relations.set_factions_community(fac_1[i], fac_2[j], -4000)
						game_relations.set_factions_community(fac_2[j], fac_1[i], -4000)
						utils.save_var( db.actor, ("drx_df_" .. fac_1[i] .. "_" .. fac_2[j] .. "_relations"), -4000)
						utils.save_var( db.actor, ("drx_df_" .. fac_2[j] .. "_" .. fac_1[i] .. "_relations"), -4000)
					end
				end
			end
			
			-- Faction defined here won't have access to all dialog
			-- This is important for ISG player to prevent him from triggering main LTTZ quests, or changing their factions in Story mode
			if faction_limited_playthrough[faction] then
				give_info("faction_limited_playthrough")
				give_info("faction_limited_playthrough_cf")
			end
		
			-- Determine total number of storyline tasks to complete for this game:
			utils.save_var( db.actor, "drx_sl_total_task_number", math.random( 8, 12 ) )  -- Set to range of total meet honcho tasks to complete to finish game
			utils.save_var( db.actor, "drx_sl_current_task_number", 1 )
	
			-- Setup DRX questlines
			xr_effects.drx_sl_setup_questlines( nil, nil, {faction} )
		else
			-- Compatibility with many story-specific mechanics.
			give_info("story_mode_disabled")
			-- Turn off the Miracle Machine:
			give_info("yan_labx16_switcher_1_off")
			give_info("yan_labx16_switcher_2_off")
			give_info("yan_labx16_switcher_3_off")
			give_info("yan_labx16_switcher_primary_off")

			-- Turn off the Brain Scorcher:
			give_info("bar_deactivate_radar_done")

			-- Turn off the Generators:
			give_info("warlab_deactivate_generators_done")
			
			-- Allow Sin and ISG squads to spawn:
			give_info("mortal_sin")
			give_info("isg_entered_the_zone")
		end
			
		config:w_value("character_creation","new_game_story_mode") -- clear value
		
		-- Set and save the current faction for later uses
		db.actor:set_character_community("actor_" .. faction, 0, 0)
		alife_storage_manager.get_state().default_faction = faction
		printdbg("- Default community setup: %s",faction)
		
		-- Reset player goodwill
		local communities = alun_utils.get_communities_list( )		
		for i, community in pairs( communities ) do
			relation_registry.set_community_goodwill( community, 0, 0 )
		end
		
		-- Money
		local money = config:r_value("character_creation","new_game_money",2)
		if money and money ~= "" then
			db.actor:give_money(-db.actor:money()+money)
		end 
		config:w_value("character_creation","new_game_money")

		-- MLR - open faction routes
		if (not mlr_utils.load_var("routes_faction")) then		
			mlr_utils.save_var("routes_faction", faction)
		end

		-- Loadout
		local sim = alife()
		local loadout = config:r_value("character_creation","new_game_loadout",3)
		local ammo_to_spawn = {}
		if loadout and loadout ~= "" then
			local t = alun_utils.str_explode(loadout,",")
			for i=1, #t do
				if ini_sys:section_exist(t[i]) then
					local to_change = { state = false }
					if ini_sys:r_string_ex(t[i],"ammo_class") then
						local slot = ini_sys:r_float_ex(t[i],"slot")
						local ani_slot = ini_sys:r_float_ex(t[i],"animation_slot")
						if slot and (((slot == 0) and (ani_slot == 1)) or (slot == 1) or (slot == 2)) then -- retarded way to know that we are dealing with weapon
							local ammo_class = ini_sys:r_string_ex(t[i],"ammo_class")
							local ammo_tbl = alun_utils.str_explode(ammo_class,",")
							local ammo_type = ini_itm:r_string_ex("ammo_type_per_wpn",t[i])
							local sec_ammo = ammo_tbl[1] --ammo_tbl[math.random(#ammo_tbl)]
							if ammo_type and ini_sys:section_exist(ammo_type) then
								to_change.state = true
								to_change.weapon_sec = t[i]
								to_change.ammo_sec = sec_ammo
								sec_ammo = ammo_type
							end
							local box_size = (ini_sys:r_float_ex(sec_ammo, "box_size") or 50)
							local count = ini_itm:r_float_ex("ammo_count",sec_ammo)
							if (not count) then
								count = (box_size < 30) and (2 * box_size) or box_size
							end
							ammo_to_spawn[sec_ammo] = ammo_to_spawn[sec_ammo] and (ammo_to_spawn[sec_ammo] + count) or count
						end
					end
					local se_obj = sim:create(t[i], db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID)
					
					-- save unique ammo type
					if se_obj and (to_change.state == true) and to_change.weapon_sec and to_change.ammo_sec then
						if (not alife_storage_manager.get_state().start_wpn_ammo) then
							alife_storage_manager.get_state().start_wpn_ammo = {}
						end
						
						alife_storage_manager.get_state().start_wpn_ammo[se_obj.id] = sec_ammo
					end
					
					-- save bolt type
					if (t[i] == "bolt") or (t[i] == "bolt_bullet") then
						saved_bolt = t[i]
					end
				end
			end
		end
		for sec,cnt in pairs(ammo_to_spawn) do
			create_ammo(sec, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID, cnt)
		end
		--sim:create("device_torch",db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),AC_ID) -- base Torch
		config:w_value("character_creation","new_game_loadout")
		
		se_actor:set_profile_name("actor_"..faction)
	end

	if (need_save) then
		config:save()
	end
end

local function actor_on_first_update(binder,delta)
	if (spawn_path) then
		start_pos = {}
		start_pos[1] = spawn_path:level_vertex_id(0)
		start_pos[2] = spawn_path:game_vertex_id(0)
		start_pos[3] = spawn_path:point(0)
	end
	
	-- Survival mode
	if (IsSurvivalMode()) then
		game_relations.change_factions_community_num("zombied",0,-5000)
		game_relations.change_factions_community_num("monolith",0,-5000)

		local faction = character_community(db.actor):sub(7)
		if (ini_sys:section_exist("survival_squad_"..faction) and start_pos) then
			local sim = alife()
			local squad = sim:create("survival_squad_"..faction,start_pos[3],start_pos[1],start_pos[2])
			if (squad) then
				axr_companions.companion_squads[squad.id] = squad
				squad:create_npc(nil,start_pos[3],start_pos[1],start_pos[2])
				local as
				for k in squad:squad_members() do
					local se_obj = k.object or k.id and sim:object(k.id)
					if (se_obj) then
						game_relations.change_factions_community_num("zombied",k.id,-5000)
						SIMBOARD:setup_squad_and_group(se_obj)
						
						utils.se_obj_save_var(se_obj.id,se_obj:name(),"companion",true)
						utils.se_obj_save_var(se_obj.id,se_obj:name(),"companion_cannot_dismiss",true)
					end
				end
			end
		end
	end
	
	if saved_bolt then
		alife_storage_manager.get_state().bolt_first = saved_bolt
	end

	if (start_pos and #start_pos == 3) then
		local warfare_enabled = alife_storage_manager.get_state().enable_warfare_mode
		if warfare_enabled and (warfare_options.options.all_out_war) then
			warfare.apply_all_out_war()
		end

		if warfare_enabled and (warfare_options.options.random_starting_locations) then
			warfare.initialize_random_starting_locations()
		else
			ChangeLevel(start_pos[3],start_pos[1],start_pos[2],VEC_ZERO)
		end
	end
end

function on_game_start()
	RegisterScriptCallback("on_game_load",on_game_load)
	RegisterScriptCallback("actor_on_first_update",actor_on_first_update)
end


--==============================================================================--
-------------------------------------< GUI >--------------------------------------
--==============================================================================--
class "faction_ui" (CUIScriptWnd)

function faction_ui:__init(owner) super()
	self.owner = owner
	
	-- Reload settings
	gs = game.translate_string
	mf = math.floor
	mc = math.ceil
	sf = string.find
	uc = utils.clamp
	clr_g = txr_utils.get_clr("d_green")
	clr_y = txr_utils.get_clr("yellow")
	clr_o = txr_utils.get_clr("d_orange")
	clr_r = txr_utils.get_clr("d_red")
	clr_b = txr_utils.get_clr("d_cyan")
	clr_b1 = txr_utils.get_clr("pda_blue")
	clr_b2 = txr_utils.get_clr("d_blue")
	clr_p = txr_utils.get_clr("d_purple")
	clr_gr = txr_utils.get_clr("ui_gray_1")

	-- Tables
	self.table_faction = {
		["stalker"] = true,
		["dolg"] = true,
		["freedom"] = true,
		["csky"] = true,
		["ecolog"] = true,
		["killer"] = true,
		["army"] = true,
		["bandit"] = true,
		["monolith"] = true,
	}
	local cfg = axr_main.config
	if cfg:r_value("unlocked_factions","renegade",1) == true then
		self.table_faction["renegade"] = true
	end
	if cfg:r_value("unlocked_factions","greh",1) == true then
		self.table_faction["greh"] = true
	end
	if cfg:r_value("unlocked_factions","isg",1) == true then
		self.table_faction["isg"] = true
	end
	
	self.table_icon = {}
	self.table_map = {}
	self.table_loadout = {}
	self.table_inv = {}
	self.table_difficulty = {"st_diff_1","st_diff_2","st_diff_3"}
	self.table_economy = {"st_econ_1","st_econ_2","st_econ_3"}
	
	self.table_hardcore_lives = {}
	local n = ini_opt:line_count("new_game_hardcore_lives") or 0
	for i=0, n-1 do
		local result, id, value = ini_opt:r_line("new_game_hardcore_lives",i,"","" )
		local t = alun_utils.str_explode(value,",")
		local size = #self.table_hardcore_lives + 1
		self.table_hardcore_lives[size] = {}
		self.table_hardcore_lives[size][1] = tonumber(t[1])
		self.table_hardcore_lives[size][2] = tostring(t[2])
	end
	
	self.table_hardcore_regen = {{nil,"st_off"}}
	local n = ini_opt:line_count("new_game_hardcore_regen") or 0
	for i=0, n-1 do
		local result, id, value = ini_opt:r_line("new_game_hardcore_regen",i,"","" )
		local t = alun_utils.str_explode(value,",")
		local size = #self.table_hardcore_regen + 1
		self.table_hardcore_regen[size] = {}
		self.table_hardcore_regen[size][1] = tonumber(t[1])
		self.table_hardcore_regen[size][2] = tostring(t[2])
	end
	
	self.table_timer = {{nil,"st_off"}}
	local n = ini_opt:line_count("new_game_timer") or 0
	for i=0, n-1 do
		local result, id, value = ini_opt:r_line("new_game_timer",i,"","" )
		local t = alun_utils.str_explode(value,",")
		local size = #self.table_timer + 1
		self.table_timer[size] = {}
		self.table_timer[size][1] = tonumber(t[1])
		self.table_timer[size][2] = tostring(t[2])
	end
	
	-- Selected choices
	self.selected_faction = "stalker"
	self.selected_icon = nil
	self.selected_map = nil
	self.selected_money = nil
	self.selected_difficulty = self.table_difficulty[1]
	self.selected_economy = self.table_economy[1]
	self.selected_hardcore_lives = self.table_hardcore_lives[1]
	self.selected_hardcore_regen = self.table_hardcore_regen[1]
	self.selected_timer = self.table_timer[1]
	self.points_left = ini_itm:r_float_ex("points","total_points_eco_1") or 1000
	self.points_used = 0
	
	-- Utility
	self.access	= true
	self.highlight_inv = nil
	self.highlight_loadout = nil
	
	-- Prepare
	self:SetWndRect				(Frect():set(0,0,1024,768))
	self:Enable					(true)

	local xml					= CScriptXmlInit()
	self.xml = xml
	xml:ParseFile				("ui_mm_faction_select.xml")

	xml:InitStatic				("background", self)
	
	-- Main
	self:Main_Controls()
	self:Main_CallBacks()
	
	-- Faction Select
	self:PopupFaction_Controls()
	--self:PopupFaction_Callbacks()
	self:PopupFaction_Show(false)
	
	-- Icon Select
	self:PopupIcon_Controls()
	self:PopupIcon_Callbacks()
	self:PopupIcon_Show(false)
end

function faction_ui:__finalize()

end

function faction_ui:Main_Controls()
	local xml = self.xml
	
	-- Background
	self.dialog					= xml:InitStatic("main_dialog:frame_back", self)
	
	
	-- Boxes
	self.box_map = xml:InitStatic("main_dialog:box_map",self.dialog)
	self.box_faction = xml:InitStatic("main_dialog:box_faction",self.dialog)
	self.box_icon = xml:InitStatic("main_dialog:box_icon",self.dialog)
	
	self.box_item = xml:InitStatic("main_dialog:box_item",self.dialog)
	self.box_item_temp = xml:InitStatic("main_dialog:box_item",self.dialog)
	
	
	-- Main frame
	self.main_frame = xml:InitStatic("main_dialog:frame_front",self.dialog)
	
	
	-- Interactive Text
	self.text_descr = xml:InitTextWnd("main_dialog:text_descr",nil)
	self.scroll_desc = xml:InitScrollView("main_dialog:scroll_desc", self.dialog)
	self.scroll_desc:AddWindow(self.text_descr, true)
	self.text_descr:SetAutoDelete(false)
	
	self.character_name = xml:InitEditBox("main_dialog:input_name",self.dialog)
	self:Register(self.character_name,"input_name")
	self.character_name:SetText("Stalker") -- Set Default Name
	
	self.text_relations = xml:InitTextWnd("main_dialog:text_relations",self.dialog)
	self.text_money = xml:InitTextWnd("main_dialog:text_money",self.dialog)
	self.text_points_left = xml:InitTextWnd("main_dialog:text_points_left",self.dialog)
	self.text_points_used = xml:InitTextWnd("main_dialog:text_points_used",self.dialog)
	
	-- Static Text
	xml:InitStatic("main_dialog:cap_character",self.dialog)
	xml:InitStatic("main_dialog:cap_options",self.dialog)
	xml:InitStatic("main_dialog:cap_inventory",self.dialog)
	xml:InitStatic("main_dialog:cap_loadout",self.dialog)
	
	xml:InitStatic("main_dialog:cap_name",self.dialog)
	xml:InitStatic("main_dialog:cap_money",self.dialog)
	xml:InitStatic("main_dialog:cap_points_left",self.dialog)
	xml:InitStatic("main_dialog:cap_points_used",self.dialog)
	
	
	-- Main Buttons
	local btn = xml:Init3tButton("main_dialog:btn_start", self.dialog)
	self:Register(btn,"btn_start")
	
	btn = xml:Init3tButton("main_dialog:btn_back", self.dialog)
	self:Register(btn,"btn_back")
	
	btn = xml:Init3tButton("main_dialog:btn_random", self.dialog)
	self:Register(btn,"btn_random")
	
	btn = xml:Init3tButton("main_dialog:btn_faction", self.dialog)
	self:Register(btn,"btn_faction")
	
	btn = xml:Init3tButton("main_dialog:btn_icon", self.dialog)
	self:Register(btn,"btn_icon")
	
	self.list_map = xml:InitComboBox("main_dialog:list_map", self.dialog)
	self.list_map:SetAutoDelete(true)
	self:Register(self.list_map, "list_map")
	
	
	-- Item Lists
	self.scroll_inv = xml:InitScrollView("main_dialog:scroll_itm_inv", self.dialog)
	self.scroll_loadout = xml:InitScrollView("main_dialog:scroll_itm_loadout", self.dialog)
	self.cells_inv = {}
	self.cells_loadout = {}
	
	
	self.ck_reset = xml:Init3tButton("main_dialog:check_reset", self.dialog)
	self:Register(self.ck_reset,"check_reset")
	
	-- Options
	self.scroll_options = xml:InitScrollView("main_dialog:scroll_options", self.dialog)
	self.templ_options = xml:InitStatic("main_dialog:templ_options",nil)
	if (USE_MARSHAL) then
		self.list_difficulty_cap = xml:InitStatic("main_dialog:list_difficulty_cap",self.dialog)
		self.list_difficulty = xml:InitComboBox("main_dialog:list_difficulty", self.dialog)
		self.list_difficulty:SetAutoDelete(true)
		self:Register(self.list_difficulty, "list_difficulty")
		self:LoadDifficulty()
		
		self.list_economy_cap = xml:InitStatic("main_dialog:list_economy_cap",self.dialog)
		self.list_economy = xml:InitComboBox("main_dialog:list_economy", self.dialog)
		self.list_economy:SetAutoDelete(true)
		self:Register(self.list_economy, "list_economy")
		self:LoadEconomy()
		
		self.ck_story_cap = xml:InitStatic("main_dialog:options:cap_check_story",self.templ_options)
		self.ck_story = xml:InitCheck("main_dialog:options:check_story",	self.templ_options)
		self:Register(self.ck_story,"check_story")
		self.ck_story:SetCheck(true) -- ON by default
		
		self.ck_hardcore_cap = xml:InitStatic("main_dialog:options:cap_check_hardcore",self.templ_options)
		self.ck_hardcore = xml:InitCheck("main_dialog:options:check_hardcore",	self.templ_options)
		self:Register(self.ck_hardcore,"check_hardcore")
		
		self.ck_azazel_mode_cap = xml:InitStatic("main_dialog:options:cap_check_azazel_mode",self.templ_options)
		self.ck_azazel_mode = xml:InitCheck("main_dialog:options:check_azazel_mode",	self.templ_options)
		self:Register(self.ck_azazel_mode,"check_azazel_mode")
		
		self.ck_survival_cap = xml:InitStatic("main_dialog:options:cap_check_survival",self.templ_options)
		self.ck_survival = xml:InitCheck("main_dialog:options:check_survival",	self.templ_options)
		self:Register(self.ck_survival,"check_survival")
		
		self.ck_warfare_cap = xml:InitStatic("main_dialog:options:cap_check_warfare",self.templ_options)
		self.ck_warfare = xml:InitCheck("main_dialog:options:check_warfare",	self.templ_options)
		self:Register(self.ck_warfare,"check_warfare")
		
		self.ck_campfire_cap = xml:InitStatic("main_dialog:options:cap_check_campfire",self.templ_options)
		self.ck_campfire = xml:InitCheck("main_dialog:options:check_campfire",	self.templ_options)
		self:Register(self.ck_campfire,"check_campfire")
		
		self.ck_routes_cap = xml:InitStatic("main_dialog:options:cap_check_routes",self.templ_options)
		self.ck_routes = xml:InitCheck("main_dialog:options:check_routes",	self.templ_options)
		self:Register(self.ck_routes,"check_routes")
		self.ck_routes:SetCheck(true) -- ON by default
		
		self.ck_conditions_cap = xml:InitStatic("main_dialog:options:cap_check_conditions",self.templ_options)
		self.ck_conditions = xml:InitCheck("main_dialog:options:check_conditions",	self.templ_options)
		self:Register(self.ck_conditions,"check_conditions")
		
		self.list_hardcore_lives_cap = xml:InitStatic("main_dialog:options:cap_list_hardcore_lives",self.templ_options)
		self.list_hardcore_lives = xml:InitComboBox("main_dialog:options:list_hardcore_lives", self.templ_options)
		self.list_hardcore_lives:SetAutoDelete(true)
		self:Register(self.list_hardcore_lives, "list_hardcore_lives")
		self:LoadHardcoreLives()
		
		self.list_hardcore_regen_cap = xml:InitStatic("main_dialog:options:cap_list_hardcore_regen",self.templ_options)
		self.list_hardcore_regen = xml:InitComboBox("main_dialog:options:list_hardcore_regen", self.templ_options)
		self.list_hardcore_regen:SetAutoDelete(true)
		self:Register(self.list_hardcore_regen, "list_hardcore_regen")
		self:LoadHardcoreRegen()
		
		self.list_timer_cap = xml:InitStatic("main_dialog:options:cap_list_timer",self.templ_options)
		self.list_timer = xml:InitComboBox("main_dialog:options:list_timer", self.templ_options)
		self.list_timer:SetAutoDelete(true)
		self:Register(self.list_timer, "list_timer")
		self:LoadTimer()
		
		self.ck_states = { 	
							--["box_faction"] = false,
							--["box_icon"] = false,
							--["list_map"] = false,
							--["ck_reset"] = false,
		
							["ck_survival"] = false,
							["ck_hardcore"] = false,
							["ck_azazel_mode"] = false,
							["ck_story"] = false,
							["ck_campfire"] = false,
							["ck_conditions"] = false,
							["ck_routes"] = false,
							["ck_warfare"] = false,
							
							["list_difficulty"] = false,
							["list_economy"] = false,
							["list_hardcore_lives"] = false,
							["list_hardcore_regen"] = false,
							["list_timer"] = false
		}
	end
	self.scroll_options:AddWindow(self.templ_options, true)
	self.templ_options:SetAutoDelete(false)
	
	-- Update info
	self:UpdateAll(false)
	
	-- Hint Window
	self.hint_wnd = xml:InitFrame("hint_wnd:background",self)
	self.hint_wnd:SetAutoDelete(false)
	self.hint_wnd_text = xml:InitTextWnd("hint_wnd:text",self.hint_wnd)
	self.hint_wnd:Show(false)
	
	
	-- Message Window 
	self.msg_wnd = xml:InitFrame("hint_wnd:background",self)
	self.msg_wnd:SetAutoDelete(false)
	self.msg_wnd_text = xml:InitTextWnd("hint_wnd:text",self.msg_wnd)
	self.msg_wnd_text:SetTextAlignment(2)
	
	self.msg_wnd:Show(false)
	self.msg_wnd:SetColor(GetARGB(255,0,0,0))
	
end

function faction_ui:Main_CallBacks()
	self:AddCallback("btn_start", ui_events.BUTTON_CLICKED, self.OnStartGame, self)
	self:AddCallback("btn_random", ui_events.BUTTON_CLICKED, self.OnRandomize, self)
	self:AddCallback("btn_back", ui_events.BUTTON_CLICKED, self.OnQuit, self)
	
	self:AddCallback("btn_faction", ui_events.BUTTON_CLICKED, self.OnFactionClicked, self)
	self:AddCallback("btn_icon", ui_events.BUTTON_CLICKED, self.OnIconClicked, self)
	
	self:AddCallback("list_map", ui_events.LIST_ITEM_SELECT, self.OnSelectMap, self)
	self:AddCallback("check_reset", ui_events.BUTTON_CLICKED, self.OnCheckResetList, self)
	
	self:AddCallback("button_inv", ui_events.BUTTON_CLICKED, self.OnInvCell_Clicked, self)
	self:AddCallback("button_loadout", ui_events.BUTTON_CLICKED, self.OnLoadoutCell_Clicked, self)
	
	self:AddCallback("check_story", ui_events.BUTTON_CLICKED, self.OnCheckSetStory, self)
	self:AddCallback("check_azazel_mode", ui_events.BUTTON_CLICKED, self.OnCheckSetAzazel, self)
	self:AddCallback("check_warfare", ui_events.BUTTON_CLICKED, self.OnCheckSetWarfare, self)
	self:AddCallback("list_difficulty", ui_events.LIST_ITEM_SELECT, self.OnSelectDifficulty, self)
	self:AddCallback("list_economy", ui_events.LIST_ITEM_SELECT, self.OnSelectEconomy, self)
	self:AddCallback("list_hardcore_lives", ui_events.LIST_ITEM_SELECT, self.OnSelectHardcoreLives, self)
	self:AddCallback("list_hardcore_regen", ui_events.LIST_ITEM_SELECT, self.OnSelectHardcoreRegen, self)
	self:AddCallback("list_timer", ui_events.LIST_ITEM_SELECT, self.OnSelectTimer, self)
end

function faction_ui:Update()
	CUIScriptWnd.Update(self)
	
	if (not self.access) then
		self.hint_wnd:Show(false)
		return
	end
	
	-- Warning messages timer 
	if (self.msg_wnd_timer and time_global() > self.msg_wnd_timer) then 
		self.msg_wnd_timer = nil
		self.msg_wnd:Show(false)
	end
	
	for ck_name,v in pairs(self.ck_states) do 
		if (self[ck_name] and self[ck_name]:IsCursorOverWindow()) then
			local str = ""
			if (ck_name == "box_faction") then
				str = strformat( gs("st_mm_box_faction_desc") , gs("st_faction_" .. self.selected_faction))
				if (self.selected_faction == "bandit") then
					str = "cheeki breeki"
				end
			else
				str = gs("st_mm_"..ck_name.."_desc")
			end
			self:SetHint(str)
			return
		end
	end
	
	for k,v in pairs(self.cells_loadout) do
		if (v.btn and v.btn:IsCursorOverWindow()) then
			local name = ui_item.get_sec_name(v.sec)
			local desc = ui_item.get_sec_desc(v.sec)
			local str = "%c[0,200,200,200]" .. name .. " \\n \\n" .. clr_b2 .. " • " .. clr_gr .. gs("st_mm_new_game_points") .. ": " .. clr_b2 .. v.points .. " \\n \\n" .. clr_gr .. desc
			self:SetHint(str)
			self.highlight_loadout = k
			return
		end
	end
	
	for k,v in pairs(self.cells_inv) do
		if (v.btn and v.btn:IsCursorOverWindow()) then
			local name = ui_item.get_sec_name(v.sec)
			local desc = ui_item.get_sec_desc(v.sec)
			local str = "%c[0,200,200,200]" .. name .. " \\n \\n" .. clr_b2 .. " • " .. clr_gr .. gs("st_mm_new_game_points") .. ": " .. clr_b2 .. v.points .. " \\n \\n" .. clr_gr .. desc
			self:SetHint(str)
			self.highlight_inv = k
			return
		end
	end
	
	self.hint_wnd:Show(false)
end 

function faction_ui:SetMsg(text,tmr)
	if (text == "") then 
		return 
	end
	self.msg_wnd:Show(true)
	self.msg_wnd_text:SetText(text)
	self.msg_wnd_text:AdjustHeightToText()
	self.msg_wnd_text:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+10))
	self.msg_wnd_text:SetWndPos(vector2():set(0,20))
	
	self.msg_wnd:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+44))
	self.msg_wnd:SetWndPos(vector2():set(0,80))

	self.msg_wnd_timer = time_global() + 1000*tmr
end

function faction_ui:SetHint(text,pos)
	if (text == "") then
		return
	end
	self.hint_wnd:Show(true)
	self.hint_wnd_text:SetText(text)
	self.hint_wnd_text:AdjustHeightToText()
	self.hint_wnd:SetWndSize(vector2():set(self.hint_wnd:GetWidth(),self.hint_wnd_text:GetHeight()+44))
	
	pos = pos or GetCursorPosition()
	pos.y = pos.y - self.hint_wnd:GetHeight()
	pos.x = pos.x - self.hint_wnd:GetWidth()
	self.hint_wnd:SetWndPos(pos)
	
	FitInRect(self.hint_wnd,Frect():set(0,0,1024,768),0,100)
end


--=======================================< Faction Select Pop-up >=======================================--
function faction_ui:PopupFaction_Controls()
	local xml = self.xml

	-- Main
	self.black_1					= xml:InitStatic("main_dialog:popup_faction:frame_black",self.dialog)
	self.dialog_1					= xml:InitStatic("main_dialog:popup_faction:frame", self.dialog)
	
	-- Static Text
	self.cap_faction = xml:InitStatic("main_dialog:popup_faction:cap_faction",self.dialog_1)
	
	-- Faction buttons
	self.scroll_faction = xml:InitScrollView("main_dialog:popup_faction:scroll_faction", self.dialog_1)
	self.btn_faction = {}
	
end

function faction_ui:PopupFaction_Callbacks()
	for k,v in pairs(self.table_faction) do
		self:AddCallback("btn_" .. k, ui_events.BUTTON_CLICKED, self["OnFaction_"..k], self)
	end
end

local faction_cell = {
	["stalker"]							= { row = 1 , col = 1},
	["bandit"]							= { row = 1 , col = 2},
    ["csky"]							= { row = 1 , col = 3},
	["dolg"]							= { row = 2 , col = 1},
	["freedom"]							= { row = 2 , col = 2},
	["killer"]							= { row = 2 , col = 3},
	["army"]							= { row = 3 , col = 1},
	["ecolog"]							= { row = 3 , col = 2},
	["monolith"]						= { row = 3 , col = 3},
	["renegade"] 						= { row = 4 , col = 1},
	["greh"] 							= { row = 4 , col = 2},
	["isg"] 							= { row = 4 , col = 3},
}
function faction_ui:PopupFaction_Show (state)
	local xml = self.xml
	local num_of_rows = math.ceil(size_table(self.table_faction)/3)
	
	self.black_1:Show(state)
	self.dialog_1:Show(state)
	self.cap_faction:Show(state)
	self.scroll_faction:Clear()
	if state then
		self.access = false
		self:PopupFaction_Callbacks()
		local _st = xml:InitStatic("main_dialog:popup_faction:templ_faction",nil)
		
		for k,v in pairs(self.table_faction) do
			self.btn_faction[k] = xml:Init3tButton("main_dialog:popup_faction:btn_" .. k , _st)
			local x,y = self:GetAxis_Icon ( self.scroll_faction, self.btn_faction[k], num_of_rows, 3, faction_cell[k].row, faction_cell[k].col )
			self.btn_faction[k]:SetWndPos(vector2():set(x, y))
			self:Register(self.btn_faction[k], "btn_" .. k )
		end
		self.scroll_faction:AddWindow(_st, true)
		_st:SetAutoDelete(false)
		
	else
		self.access = true
	end
end

function faction_ui:OnFactionSelect(faction)
	self.selected_faction = faction
	self:UpdateAll(false, self.selected_faction)
	self:PopupFaction_Show(false)
	if faction_no_story[faction] then
		self.ck_story:SetCheck(false)
		self.ck_story:Enable(false)
	else
		self.ck_story:Enable(true)
	end
end

function faction_ui:OnFaction_stalker()
	self:OnFactionSelect("stalker")
end
function faction_ui:OnFaction_bandit()
	self:OnFactionSelect("bandit")
end
function faction_ui:OnFaction_csky()
	self:OnFactionSelect("csky")
end
function faction_ui:OnFaction_dolg()
	self:OnFactionSelect("dolg")
end
function faction_ui:OnFaction_freedom()
	self:OnFactionSelect("freedom")
end
function faction_ui:OnFaction_killer()
	self:OnFactionSelect("killer")
end
function faction_ui:OnFaction_army()
	self:OnFactionSelect("army")
end
function faction_ui:OnFaction_ecolog()
	self:OnFactionSelect("ecolog")
end
function faction_ui:OnFaction_monolith()
	self:OnFactionSelect("monolith")
end
function faction_ui:OnFaction_renegade()
	self:OnFactionSelect("renegade")
end
function faction_ui:OnFaction_greh()
	self:OnFactionSelect("greh")
end
function faction_ui:OnFaction_isg()
	self:OnFactionSelect("isg")
end
function faction_ui:OnFaction_zombied()
	self:OnFactionSelect("zombied")
end


--=======================================< Icon Select Pop-up >=======================================--
function faction_ui:PopupIcon_Controls()
	local xml = self.xml
	
	-- Main
	self.black_2					= xml:InitStatic("main_dialog:popup_icon:frame_black",self.dialog)
	self.dialog_2					= xml:InitStatic("main_dialog:popup_icon:frame", self.dialog)
	
	-- Static Text
	self.cap_icon = xml:InitStatic("main_dialog:popup_icon:cap_icon",self.dialog_2)
	
	-- Faction buttons
	self.scroll_icon = xml:InitScrollView("main_dialog:popup_icon:scroll_icon", self.dialog_2)
	
	-- Size Reference
	self.tempy_icon = xml:InitStatic("main_dialog:popup_icon:temp_icon" , self.dialog_2)
	
	self.btn_icon = {}
	self.temp_icon = {}
end

function faction_ui:PopupIcon_Callbacks()
	for i = 1 , 30 do
		self:AddCallback("btn_icon_" .. tostring(i), ui_events.BUTTON_CLICKED, self["OnIcon_" .. tostring(i)], self)
	end
end

function faction_ui:PopupIcon_Show (state)
	local xml = self.xml
	
	self.black_2:Show(state)
	self.dialog_2:Show(state)
	self.cap_icon:Show(state)
	self.scroll_icon:Clear()
	if state then
		local _st = xml:InitStatic("main_dialog:popup_icon:templ_icon",nil)
		self.access = false
		
		local n = 10
		local x = 20
		local w = self.tempy_icon:GetWidth()
		local h = self.tempy_icon:GetHeight()
		for i = 1 , #self.table_icon do
			self.temp_icon[i] = xml:InitStatic("main_dialog:popup_icon:temp_icon" , _st)
			self.temp_icon[i]:InitTexture(self.table_icon[i])
			self.temp_icon[i]:SetStretchTexture(true)
			self.temp_icon[i]:SetWndSize(vector2():set(w , h))
			self.btn_icon[i] = xml:Init3tButton("main_dialog:popup_icon:btn_icon" , _st)
			
			self.temp_icon[i]:SetWndPos(vector2():set(x, n))
			self.btn_icon[i]:SetWndPos(vector2():set(x, n))
			
			self:Register(self.temp_icon[i], "btn_icon_" .. tostring(i) )
			self:Register(self.btn_icon[i], "btn_icon_" .. tostring(i) )
			n = n + h + 10
		end
		for i = #self.table_icon + 1 , 50 do -- everything else is thrown outside
			if self.temp_icon[i] and self.btn_icon[i] then
				self.temp_icon[i]:SetWndPos(vector2():set(x + 200, 0))
				self.btn_icon[i]:SetWndPos(vector2():set(x + 200, 0))
			end
		end
		_st:SetWndSize(vector2():set(_st:GetWidth(), n - 2 ))
		self.scroll_icon:AddWindow(_st, true)
		_st:SetAutoDelete(false)
	else
		self.access = true
	end
end

function faction_ui:OnIconSelect(num)
	self.selected_icon = self.table_icon[num]
	self:UpdateIcon()
	self:PopupIcon_Show(false)
end

function faction_ui:OnIcon_1()
	self:OnIconSelect(1)
end
function faction_ui:OnIcon_2()
	self:OnIconSelect(2)
end
function faction_ui:OnIcon_3()
	self:OnIconSelect(3)
end
function faction_ui:OnIcon_4()
	self:OnIconSelect(4)
end
function faction_ui:OnIcon_5()
	self:OnIconSelect(5)
end
function faction_ui:OnIcon_6()
	self:OnIconSelect(6)
end
function faction_ui:OnIcon_7()
	self:OnIconSelect(7)
end
function faction_ui:OnIcon_8()
	self:OnIconSelect(8)
end
function faction_ui:OnIcon_9()
	self:OnIconSelect(9)
end
function faction_ui:OnIcon_10()
	self:OnIconSelect(10)
end
function faction_ui:OnIcon_11()
	self:OnIconSelect(11)
end
function faction_ui:OnIcon_12()
	self:OnIconSelect(12)
end
function faction_ui:OnIcon_13()
	self:OnIconSelect(13)
end
function faction_ui:OnIcon_14()
	self:OnIconSelect(14)
end
function faction_ui:OnIcon_15()
	self:OnIconSelect(15)
end
function faction_ui:OnIcon_16()
	self:OnIconSelect(16)
end
function faction_ui:OnIcon_17()
	self:OnIconSelect(17)
end
function faction_ui:OnIcon_18()
	self:OnIconSelect(18)
end
function faction_ui:OnIcon_19()
	self:OnIconSelect(19)
end
function faction_ui:OnIcon_20()
	self:OnIconSelect(20)
end
function faction_ui:OnIcon_21()
	self:OnIconSelect(21)
end
function faction_ui:OnIcon_22()
	self:OnIconSelect(22)
end
function faction_ui:OnIcon_23()
	self:OnIconSelect(23)
end
function faction_ui:OnIcon_24()
	self:OnIconSelect(24)
end
function faction_ui:OnIcon_25()
	self:OnIconSelect(25)
end
function faction_ui:OnIcon_26()
	self:OnIconSelect(26)
end
function faction_ui:OnIcon_27()
	self:OnIconSelect(27)
end
function faction_ui:OnIcon_28()
	self:OnIconSelect(28)
end
function faction_ui:OnIcon_29()
	self:OnIconSelect(29)
end
function faction_ui:OnIcon_30()
	self:OnIconSelect(30)
end
function faction_ui:OnIcon_31()
	self:OnIconSelect(31)
end
function faction_ui:OnIcon_32()
	self:OnIconSelect(32)
end
function faction_ui:OnIcon_33()
	self:OnIconSelect(33)
end
function faction_ui:OnIcon_34()
	self:OnIconSelect(34)
end
function faction_ui:OnIcon_35()
	self:OnIconSelect(35)
end
function faction_ui:OnIcon_36()
	self:OnIconSelect(36)
end
function faction_ui:OnIcon_37()
	self:OnIconSelect(37)
end
function faction_ui:OnIcon_38()
	self:OnIconSelect(38)
end
function faction_ui:OnIcon_39()
	self:OnIconSelect(39)
end
function faction_ui:OnIcon_40()
	self:OnIconSelect(40)
end
function faction_ui:OnIcon_41()
	self:OnIconSelect(41)
end
function faction_ui:OnIcon_42()
	self:OnIconSelect(42)
end
function faction_ui:OnIcon_43()
	self:OnIconSelect(43)
end
function faction_ui:OnIcon_44()
	self:OnIconSelect(44)
end
function faction_ui:OnIcon_45()
	self:OnIconSelect(45)
end
function faction_ui:OnIcon_46()
	self:OnIconSelect(46)
end
function faction_ui:OnIcon_47()
	self:OnIconSelect(47)
end
function faction_ui:OnIcon_48()
	self:OnIconSelect(48)
end
function faction_ui:OnIcon_49()
	self:OnIconSelect(49)
end
function faction_ui:OnIcon_50()
	self:OnIconSelect(50)
end


--=======================================< Prepare the droplists / Update the info >=======================================--
function faction_ui:LoadFaction (rand, faction)
	local pick = faction
	if (not pick) then
		local k = random_key_table(self.table_faction)
		pick = rand and k or "stalker"
	end
	
	self.selected_faction = pick
	local money = alun_utils.read_from_ini(ini_itm, self.selected_faction .. "_money", "money", "float")
	self.selected_money = money
	
	self:UpdateFaction()
	self:UpdateMoney()
end

function faction_ui:LoadIcon (rand)
	local def_icon = "ui_inGame2_no_data"
	self.table_icon = {}
	table.insert(self.table_icon, def_icon)

	local section = self.selected_faction .. "_portraits"
	local n = ini_ico:section_exist(section) and ini_ico:line_count(section) or 0
	for i=0 , n-1 do
		local result, id, value = ini_ico:r_line(section,i,"","" )
		if (id ~= "") then
			table.insert(self.table_icon, id)
		end
	end
	
	local pick = rand and self.table_icon[math.random(#self.table_icon)] or def_icon
	
	self.selected_icon = pick
	self:UpdateIcon()
end

function faction_ui:LoadMap (rand)
	self.table_map = {}
	
	if (not rand) then
		table.insert(self.table_map, "random_location")
	end
	
	local n = ini_map:line_count(self.selected_faction .. "_start_locations") or 0
	for i=0, n-1 do
		local result, id, value = ini_map:r_line(self.selected_faction.."_start_locations",i,"","" )
		if value then
			local tbl = alun_utils.str_explode(value,",")
			if self.ck_story and self.ck_story:GetCheck() then
				if (tbl[2] == "true") or (tbl[2] == "false") then
					table.insert(self.table_map, id)
				end
			elseif tbl[2] ~= "false" then
				table.insert(self.table_map, id)
			end
		end
	end
	
	self.list_map:ClearList()
	for i=1,#self.table_map do
		self.list_map:AddItem(gs("ui_st_" .. self.table_map[i]), i)
	end
	local pick = rand and self.table_map[math.random(#self.table_map)] or self.table_map[1]
	self.list_map:SetText(gs("ui_st_" .. pick))
	
	self.selected_map = pick
	self:UpdateMap()
end

function faction_ui:LoadLoadout (rand)
	
	-- Reset
	local eco_idxs = self.selected_economy:gsub("st_econ_","") or "1"
	self.points_used = 0
	self.points_left = ini_itm:r_float_ex("points","total_points_eco_" .. eco_idxs) or 1000
	self.text_points_used:SetText(tostring(self.points_used))
	self.text_points_left:SetText(tostring(self.points_left))
	

	-- Read
	empty_table(self.table_inv)
	empty_table(self.table_loadout)
	local n = ini_itm:line_count(self.selected_faction .. "_loadout") or 0
	local w,h
	local k1,k2 = 0,0
	for i=0, n-1 do
		local result, id, value = ini_itm:r_line(self.selected_faction .. "_loadout" , i , "", "")
		if ini_sys:section_exist(id) then
			w = ini_sys:r_float_ex(id,"inv_grid_width")
			h = ini_sys:r_float_ex(id,"inv_grid_height")
			local t = alun_utils.str_explode(value,",")
			if (not t[4]) or (t[4] and (tonumber(eco_idxs) <= tonumber(t[4]))) then
				if (t[1] == "false") then
					for i=1,tonumber(t[2]) do
						k1 = k1 + 1
						self.table_inv[k1] = { sec = id , points = 0 , w = w , h = h }
					end
				elseif (t[1] == "true") then
					for i=1,tonumber(t[2]) do
						k2 = k2 + 1
						self.table_loadout[k2] = { sec = id ,  points = tonumber(t[3]) , w = w , h = h }
					end
				end
			end
		end
	end
	
	-- Update UI
	self:InitInventoryCells(self.table_inv, self.scroll_inv, self.cells_inv, "button_inv")
	self:InitInventoryCells(self.table_loadout, self.scroll_loadout, self.cells_loadout, "button_loadout")
	
	-- Pick randomly
	if (not rand) then
		return
	end
	
	while true do
		local key = random_key_table(self.table_loadout)
		if (not key) then return end
		local item = self.table_loadout[key]
		if not (item) then
			break
		end
		
		local points = item.points
		if (points > self.points_left) then
			break
		end
		
		self.points_used = self.points_used + points
		self.points_left = self.points_left - points
	
		for i=1,1000 do
			if (not self.table_inv[i]) then
				self.table_inv[i] = {}
				self.table_inv[i].sec = item.sec
				self.table_inv[i].points = item.points
				self.table_inv[i].w = item.w
				self.table_inv[i].h = item.h
				self.table_loadout[key] = nil
				break
			end
		end
	end
	
	self.text_points_used:SetText(tostring(self.points_used))
	self.text_points_left:SetText(tostring(self.points_left))
	self:InitInventoryCells(self.table_inv, self.scroll_inv, self.cells_inv, "button_inv")
	self:InitInventoryCells(self.table_loadout, self.scroll_loadout, self.cells_loadout, "button_loadout")
end

function faction_ui:InitInventoryCells(s_table, s_scroll, s_cells, callback)
	local xml = self.xml

	local function count_grids_num(t, tot_w)
		local cnt = 0
		for _,v in pairs(t) do
			--printf("- %s | key: %s - id: %s - w: %s - h: %s - points: %s",callback,tostring(_),tostring(v.sec),tostring(v.w),tostring(v.h),tostring(v.points))
			cnt = cnt + (v.w * v.h)
		end
		local rows = math.ceil(cnt/tot_w)
		return (rows * tot_w)
	end
	
	s_scroll:Clear()
	empty_table(s_cells)
	
	local _st = xml:InitStatic("main_dialog:inv_form", nil)
	
	local grid = xml:InitStatic("inv_grid", nil)
	local grid_w = grid:GetWidth()
	local grid_h = grid:GetHeight()
	local tot_grid_w = math.floor(_st:GetWidth() / grid_w)
	local tot_grid_h = math.floor(_st:GetHeight() / grid_h)
	local tot_grid_num = math.max( count_grids_num(s_table, tot_grid_w) , (tot_grid_w * tot_grid_h))
	local tot_grid_ind = {}
	for i=1,tot_grid_num do
		local row = mc(i/tot_grid_w)
		tot_grid_ind[row] = tot_grid_ind[row] or {}
		tot_grid_ind[row][#tot_grid_ind[row] + 1] = true
	end

	for k,v in pairs(s_table) do
		s_cells[k] = {}
		s_cells[k].ico_tmp = xml:InitStatic("inv_grid", _st)
		s_cells[k].btn = xml:Init3tButton("inv_btn_" .. tostring(v.w) .. "_" .. tostring(v.h), _st)
		s_cells[k].ico = xml:InitStatic("inv_grid", _st)
		s_cells[k].ico_s = xml:InitStatic("inv_grid", _st)
		s_cells[k].sec = v.sec
		s_cells[k].points = v.points
		
		tot_grid_h = txr_utils.set_grid_element(
			{ id = k , sec = v.sec , g_w = grid_w , g_h = grid_h , w = v.w , h = v.h , g_row = tot_grid_w },
			tot_grid_ind,
			s_cells[k].btn, s_cells[k].ico, s_cells[k].ico_s, s_cells[k].ico_tmp
		)
		txr_utils.set_up_icon(v.sec, nil, s_cells[k].ico_tmp, s_cells[k].ico, s_cells[k].ico_s)
		self:Register(s_cells[k].btn, callback)
	end
	
	_st:SetWndSize(vector2():set(_st:GetWidth(),tot_grid_h * grid_h))
	s_scroll:AddWindow(_st, true)
	_st:SetAutoDelete(false)
end

function faction_ui:LoadDifficulty (rand)
	self.list_difficulty:ClearList()
	for i=1,#self.table_difficulty do
		self.list_difficulty:AddItem(gs(self.table_difficulty[i]), i)
	end
	local pick = rand and self.table_difficulty[math.random(#self.table_difficulty)] or self.table_difficulty[1]
	self.list_difficulty:SetText(gs(pick))
	self.selected_difficulty = pick
end

function faction_ui:LoadEconomy (rand)
	self.list_economy:ClearList()
	for i=1,#self.table_economy do
		self.list_economy:AddItem(gs(self.table_economy[i]), i)
	end
	local pick = rand and self.table_economy[math.random(#self.table_economy)] or self.table_economy[1]
	self.list_economy:SetText(gs(pick))
	self.selected_economy = pick
end

function faction_ui:LoadHardcoreLives (rand)
	local str
	self.list_hardcore_lives:ClearList()
	for i=1, #self.table_hardcore_lives do
		str = self.table_hardcore_lives[i][1] or ""
		self.list_hardcore_lives:AddItem(str .. " " .. gs(self.table_hardcore_lives[i][2]), i)
	end
	local pick = rand and self.table_hardcore_lives[math.random(#self.table_hardcore_lives)] or self.table_hardcore_lives[1]
	str = pick[1] or ""
	self.list_hardcore_lives:SetText(str .. " " .. gs(pick[2])) 
	self.selected_hardcore_lives = pick
end

function faction_ui:LoadHardcoreRegen (rand)
	local str
	self.list_hardcore_regen:ClearList()
	for i=1, #self.table_hardcore_regen do
		str = self.table_hardcore_regen[i][1] and tostring(utils.round(self.table_hardcore_regen[i][1]/24)) or ""
		self.list_hardcore_regen:AddItem(str .. " " .. gs(self.table_hardcore_regen[i][2]), i)
	end
	local pick = rand and self.table_hardcore_regen[math.random(#self.table_hardcore_regen)] or self.table_hardcore_regen[1]
	str = pick[1] and tostring(utils.round(pick[1]/24)) or ""
	self.list_hardcore_regen:SetText(str .. " " .. gs(pick[2])) 
	self.selected_hardcore_regen = pick
end

function faction_ui:LoadTimer (rand)
	local str
	self.list_timer:ClearList()
	for i=1, #self.table_timer do
		str = self.table_timer[i][1] or ""
		self.list_timer:AddItem(str .. " " .. gs(self.table_timer[i][2]), i)
	end
	local pick = rand and self.table_timer[math.random(#self.table_timer)] or self.table_timer[1]
	str = pick[1] or ""
	self.list_timer:SetText(str .. " " .. gs(pick[2]))
	self.selected_timer = pick
end


--=======================================< GUI Callbacks >=======================================-
function faction_ui:OnFactionClicked()
	if (not self.access) then
		return
	end
	
	self:PopupFaction_Show(true)
end

function faction_ui:OnIconClicked()
	if (not self.access) then
		return
	end
	
	self:PopupIcon_Show(true)
end

function faction_ui:OnSelectMap()
	self.selected_map = self.table_map[self.list_map:CurrentID()]
	self:UpdateMap()
end

function faction_ui:OnInvCell_Clicked()
	if not (self.access and self.highlight_inv) then
		return
	end

	local item = self.table_inv[self.highlight_inv]
	if not (item) then
		return
	end
	
	local points = item.points
	if (points == 0) then
		return
	end
	self.points_used = self.points_used - points
	self.points_left = self.points_left + points

	self.text_points_used:SetText(tostring(self.points_used))
	self.text_points_left:SetText(tostring(self.points_left))

	self.access = false
	for i=1,1000 do
		--printf("i= %s",i)
		if (not self.table_loadout[i]) then
			self.table_loadout[i] = {}
			copy_table(self.table_loadout[i], item)
			self.table_inv[self.highlight_inv] = nil
			break
		end
	end

	self.highlight_inv = nil
	self.highlight_loadout = nil
	self:InitInventoryCells(self.table_inv, self.scroll_inv, self.cells_inv, "button_inv")
	self:InitInventoryCells(self.table_loadout, self.scroll_loadout, self.cells_loadout, "button_loadout")
	self.access = true
end

function faction_ui:OnLoadoutCell_Clicked()
	if not (self.access and self.highlight_loadout) then
		return
	end
	
	local item = self.table_loadout[self.highlight_loadout]
	if not (item) then
		return
	end
	
	local points = item.points
	
	if (points > self.points_left) then
		return
	end
	
	self.points_used = self.points_used + points
	self.points_left = self.points_left - points
	
	self.text_points_used:SetText(tostring(self.points_used))
	self.text_points_left:SetText(tostring(self.points_left))
	
	self.access = false
	for i=1,1000 do
		if (not self.table_inv[i]) then
			self.table_inv[i] = {}
			copy_table(self.table_inv[i], item)
			self.table_loadout[self.highlight_loadout] = nil
			break
		end
	end
	
	self.highlight_inv = nil
	self.highlight_loadout = nil
	self:InitInventoryCells(self.table_inv, self.scroll_inv, self.cells_inv, "button_inv")
	self:InitInventoryCells(self.table_loadout, self.scroll_loadout, self.cells_loadout, "button_loadout")
	self.access = true
end

function faction_ui:OnSelectDifficulty()
	self.selected_difficulty = self.table_difficulty[self.list_difficulty:CurrentID()]
end

function faction_ui:OnSelectEconomy()
	self.selected_economy = self.table_economy[self.list_economy:CurrentID()]
	self:LoadLoadout()
end

function faction_ui:OnSelectHardcoreLives()
	self.selected_hardcore_lives = self.table_hardcore_lives[self.list_hardcore_lives:CurrentID()]
end

function faction_ui:OnSelectHardcoreRegen()
	self.selected_hardcore_regen = self.table_hardcore_regen[self.list_hardcore_regen:CurrentID()]
end

function faction_ui:OnSelectTimer()	
	self.selected_timer = self.table_timer[self.list_timer:CurrentID()]
end

function faction_ui:OnCheckSetStory()
	if (not self.access) then
		return
	end
	
	self.ck_azazel_mode:SetCheck(false)
	self.ck_states["ck_azazel_mode"] = false
	
	self.ck_warfare:SetCheck(false)
	self.ck_states["ck_warfare"] = false
	
	self:LoadMap()
end

function faction_ui:OnCheckSetAzazel()
	if (not self.access) then
		return
	end
	
	self.ck_story:SetCheck(false)
	self.ck_states["ck_story"] = false
	
	self:LoadMap()
end

function faction_ui:OnCheckSetWarfare()
	if (not self.access) then
		return
	end
	
	self.ck_story:SetCheck(false)
	self.ck_states["ck_story"] = false
	
	self:LoadMap()
end

function faction_ui:OnCheckResetList()
	if (not self.access) then
		return
	end
	
	self:LoadLoadout()
end


--=======================================< Update visuals >=======================================--
function faction_ui:UpdateAll (rand, faction)
	self:LoadFaction(rand, faction)
	self:LoadIcon(rand)
	self:LoadMap(rand)
	
	self:UpdateMoney()
	self:UpdateDescr()

	self:LoadLoadout(rand)
end

function faction_ui:UpdateFaction()
	self.box_faction:InitTexture("ui_new_game_flair_" .. self.selected_faction)
	self.box_faction:SetStretchTexture(true)
	self.box_faction:SetWndSize(vector2():set(self.box_faction:GetWidth(),self.box_faction:GetHeight()))
end

function faction_ui:UpdateIcon()
	self.box_icon:InitTexture(self.selected_icon)
	self.box_icon:SetStretchTexture(true)
	self.box_icon:SetWndSize(vector2():set(self.box_icon:GetWidth(),self.box_icon:GetHeight()))
end

function faction_ui:UpdateMap()
	local map_pic = (self.selected_map ~= "random_location") and self.selected_map or self.table_map[2]
	local map = alun_utils.read_from_ini(ini_map, self.selected_faction .. "_start_locations", map_pic, "string")
	map = alun_utils.str_explode(map,",") 
	
	self.box_map:InitTexture("ui_new_game_map_" .. map[1])
	self.box_map:SetStretchTexture(true)
	self.box_map:SetWndSize(vector2():set(self.box_map:GetWidth(),self.box_map:GetHeight()))
end

function faction_ui:UpdateMoney()
	self.text_money:SetText(tostring(self.selected_money) .. " RU")
end

function faction_ui:UpdateDescr()
	local faction = self.selected_faction 
	
	-- Description and map
	local desc = "%c[0,250,250,250]" .. gs("st_mm_new_game_description")
	desc = desc .. "\\n%c[0,150,150,150]" .. gs("st_faction_" .. faction .. "_desc")
	
	self.text_descr:SetText(desc)
	self.text_descr:AdjustHeightToText()
	self.text_descr:SetWndSize(vector2():set(self.text_descr:GetWidth(),self.text_descr:GetHeight()+10))
	self.scroll_desc:Clear()
	self.scroll_desc:AddWindow(self.text_descr, true)
	self.text_descr:SetAutoDelete(false)
	
	-- Relations
	local str_stats = "%c[0,250,250,250]" .. gs("st_mm_new_game_relations") .. " \\n"
	for k,v in pairs(self.table_faction) do
		if not (k == faction) then
			local v = relation_registry.community_relation("actor_" .. faction, k)
			if (v >= 1000) then
				str_stats = str_stats .. "%c[0,150,150,150]• %c[0,50,175,50]" .. gs("st_faction_" .. k) .. "\\n"
			elseif (v <= -1000) then
				str_stats = str_stats .. "%c[0,150,150,150]• %c[0,175,50,50]" .. gs("st_faction_" .. k) .. "\\n"
			else
				str_stats = str_stats .. "%c[0,150,150,150]• %c[0,175,175,50]" .. gs("st_faction_" .. k) .. "\\n"
			end
		end
	end
	
	self.text_relations:SetText(str_stats)
	self.text_relations:AdjustHeightToText()
end

function faction_ui:GetAxis_Icon (main , element , all_row , all_col , row , col)
	local _w = main:GetWidth()
	local _h = main:GetHeight()
	local _wi = element:GetWidth()
	local _hi = element:GetHeight()
	local off_x = (_w - _wi * all_col)/(all_col+1)
	local off_y = (_h - _hi * all_row)/(all_row+1)
	
	local x = (off_x * col) + (_wi * (col - 1))
	local y = (off_y * row) + (_hi * (row - 1))
	return x,y
end


--=======================================< Main Buttons >=======================================--
function faction_ui:OnQuit()
	if (not self.access) then
		return
	end
	
	self.owner:ShowDialog(true)
	self.owner:Show(true)
	if (self:IsShown()) then
		self:HideDialog()
	end
	self:Show(false)
	--ui_main_menu.RemoveFactionUI()
end

function faction_ui:OnRandomize()
	if (not self.access) then
		return
	end
	
	-- Faction
	self.selected_faction  = random_key_table(self.table_faction)
	
	-- Name
	local subset
	if (self.selected_faction == "army" or self.selected_faction == "dolg" or self.selected_faction == "isg") then 
		subset = random_choice("private","sergeant","senior_sergeant","lieutenant","captain")
	else 
		subset = random_choice("stalker","bandit","science")
	end
	local name_cnt = ini_sys:r_float_ex("stalker_names_"..subset,"name_cnt")
	local last_name_cnt = ini_sys:r_float_ex("stalker_names_"..subset,"last_name_cnt")
	local first_name = gs( strformat("name_%s_%s",subset,math.random(0,name_cnt-1)) )
	local last_name = gs( strformat("lname_%s_%s",subset,math.random(0,last_name_cnt-1)) )
	self.character_name:SetText(first_name .. " " .. last_name)
	
	-- Difficulty and Economy
	self:LoadDifficulty(true)
	self:LoadEconomy(true)
	
	-- Everything else
	self:UpdateAll(true, self.selected_faction)
end

local char_cache = ""
local passwords = {
	["renegade"] = "19_18_49_18_34_30_32_18", -- R E N E G A D E
	["greh"] = "34_19_18_35", -- G R E H
	["isg"] = "23_31_34", -- I S G
}
function faction_ui:OnKeyboard(dik, keyboard_action)
	if (not self.access) then
		return
	end
	
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
			if dik == DIK_keys.DIK_ESCAPE then
				self:OnQuit()
			elseif (dik == DIK_keys.DIK_Z) then
				self.selected_faction = "zombied"
				if faction_no_story[self.selected_faction] then
					self.ck_story:SetCheck(false)
					self.ck_story:Enable(false)
				else
					self.ck_story:Enable(true)
				end
				self:UpdateAll(false , self.selected_faction)
			end
			
			char_cache = char_cache .. tostring(dik) .. "_"
			for k,v in pairs(passwords) do
				if string.find(char_cache,v) then
					self.table_faction[k] = true
				end
			end
			
		end
	end
	return res
end

function faction_ui:OnStartGame()
	if (not self.access) then
		return
	end

	-- start game anyway if no config or axr_main script
	if not (axr_main and axr_main.config) then
		self.owner:StartGame()
		return
	end
	
	-- check name
	local character_name = self.character_name:GetText()
	if (character_name == "") then
		-- Require a name to be entered.
		return
	end
	
	-- check location
	if (self.selected_map == nil or self.selected_map == "" or self.selected_map == "random_location" or self.list_map:CurrentID() < 0) then
		local index = math.random(2,#self.table_map)
		self.selected_map = self.table_map[index]
	end
	
	-- save modes
	local hardcore_regen
	if (self.selected_hardcore_regen[1]) and (type(self.selected_hardcore_regen[1]) == "number") then
		hardcore_regen = self.selected_hardcore_regen[1]
	end
	
	local timer
	if (self.selected_timer[1]) and (type(self.selected_timer[1]) == "number") then
		timer = self.selected_timer[1]
	end
	
	-- prepare loadout
	local loadout_str
	for k,v in pairs(self.table_inv) do
		if (not loadout_str) then
			loadout_str = v.sec
		else
			loadout_str = loadout_str .. "," .. v.sec
		end
	end

	-- preparing game difficulty values
	if (self.selected_difficulty == nil or self.selected_difficulty == "") then
		self.selected_difficulty = self.table_difficulty[1]
	end
	local diff = self.selected_difficulty:gsub("st_diff_","")
	diff = tonumber(diff) or 1
	
	-- preparing economy values
	if (self.selected_economy == nil or self.selected_economy == "") then
		self.selected_economy = self.table_economy[1]
	end
	local econ = self.selected_economy:gsub("st_econ_","")
	econ = tonumber(econ) or 1
	
	if (self.ck_warfare and self.ck_warfare:GetCheck()) and (warfare_options.options.random_starting_locations) then
		self.selected_map = warfare_options.get_random_start_location()	
	end	
	
	axr_main.config:w_value("character_creation","new_game_difficulty",diff)
	axr_main.config:w_value("character_creation","new_game_economy",econ)
	axr_main.config:w_value("character_creation","new_game_economy_treasure",econ) -- special for treasure_manager
	
	axr_main.config:w_value("character_creation","new_game_hardcore_mode",self.ck_hardcore and self.ck_hardcore:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_hardcore_mode_lives",self.ck_hardcore and self.selected_hardcore_lives[1] or nil)
	axr_main.config:w_value("character_creation","new_game_hardcore_mode_regenerate",self.ck_hardcore and hardcore_regen or nil)
	axr_main.config:w_value("character_creation","new_game_story_mode",self.ck_story and self.ck_story:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_azazel_mode",self.ck_azazel_mode and self.ck_azazel_mode:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_survival_mode",self.ck_survival and self.ck_survival:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_campfire_mode",self.ck_campfire and self.ck_campfire:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_conditions_mode",self.ck_conditions and self.ck_conditions:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_opened_routes",self.ck_routes and self.ck_routes:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_warfare",self.ck_warfare and self.ck_warfare:GetCheck() and true or nil) -- special for warfare
	axr_main.config:w_value("character_creation","new_game_timer_mode",timer or nil)
	
	axr_main.config:w_value("character_creation","new_game_character_name",character_name:gsub(" ","_") )
	axr_main.config:w_value("character_creation","new_game_faction",self.selected_faction or nil)
	axr_main.config:w_value("character_creation","new_game_icon",self.selected_icon or nil)
	axr_main.config:w_value("character_creation","new_game_loadout",loadout_str or nil)
	axr_main.config:w_value("character_creation","new_game_map",self.selected_map or nil)
	axr_main.config:w_value("character_creation","new_game_money",self.selected_money or nil)
	
	axr_main.config:save() -- Store info in temp file
	self.owner:StartGame() -- Start the game
end

