
-- =======================================================================================
-- Created by Tronex
-- 2019/2/23
-- Workshop UI
-- Repair/Upgrade/Craft interfaces in one
-- Welcome to XML hell boi!
-- =======================================================================================


workshop_toolkits = {
	"itm_basickit",
	"itm_advancedkit",
	"itm_expertkit",
	"itm_drugkit",
	"itm_ammokit",
}

local enable_debug = false

local rw, rh = 1,1
local ini_parts, ini_craft
local mf,mc,sf
local clr_g,clr_y,clr_o,clr_r,clr_b,clr_b1,clr_b2,clr_p,clr_dark
local ini_upgr_props = ini_file("items\\weapons\\upgrades_properties.ltx")

local upg_tbl = {}
local upg_gr = {
	[1] = "first",
	[2] = "secon",
	[3] = "third",
	[4] = "fourt",
	[5] = "fifth",
}
local upg_ind = {
	[1] = "a",
	[2] = "b",
	[3] = "c",
	[4] = "d",
	[5] = "e",
	[6] = "f",
}
for i=1,#upg_gr do
    for ii=1,#upg_ind do
        upg_tbl[#upg_tbl+1] = upg_gr[i] .. upg_ind[ii]
    end
end


local instance = nil -- don't touch
function get_workshop_ui(...)
	--instance = instance or workshop_ui(...)
	--return instance
	
	return workshop_ui(...)
end


--=======================================< List Item >=======================================--
class "list_element" (CUIListBoxItem)

function list_element:__init(idx, name) super(idx, name)
	
	self.idx					= idx
	self.name					= name

	self.text					= self:GetTextItem()
	self.text:SetWndRect		(Frect():set(0,0,300,22))
	self:SetTextColor			(GetARGB(255, 130, 128, 120))
	self.text:SetFont			(GetFontLetterica18Russian())
	self.text:SetWndSize		(vector2():set(400,22))
	self.text:SetEllipsis		(true)
	self.text:SetText			(game.translate_string(self.name))
end

function list_element:__finalize()
end



--######################################################################################################################
--#														< WOKSHOP > 	  												#
--######################################################################################################################

class "workshop_ui" (CUIScriptWnd)

function workshop_ui:__init(owner, mechanic, toolkits_workshop, dbg) super()
	self.dbg = dbg and true or false
	self.owner = owner
	self.mechanic = mechanic
	self.toolkits_workshop = toolkits_workshop or {}
	self.toolkits_state = {}
	for i=1,#workshop_toolkits do
		if self.toolkits_workshop[i] or db.actor:object(workshop_toolkits[i]) then
			self.toolkits_state[i] = true
		else
			self.toolkits_state[i] = false
		end
	end
	
	-- Reload settings
	ini_parts = itms_manager.ini_parts
	ini_craft = itms_manager.ini_craft
	mf = math.floor
	mc = math.ceil
	sf = string.find
	clr_g = txr_utils.get_clr("d_green")
	clr_y = txr_utils.get_clr("yellow")
	clr_o = txr_utils.get_clr("d_orange")
	clr_r = txr_utils.get_clr("d_red")
	clr_b = txr_utils.get_clr("d_cyan")
	clr_b1 = txr_utils.get_clr("pda_blue")
	clr_b2 = txr_utils.get_clr("d_blue")
	clr_p = txr_utils.get_clr("d_purple")
	clr_dark = txr_utils.get_clr("ui_gray_2")
	
	self:InitControls()
	self:InitCallBacks()
	
	self:Reset()
end

function workshop_ui:__finalize()
end

function workshop_ui:InitControls()
	self:SetWndRect(Frect():set(0,0,1024,768))
	self:SetAutoDelete(true)
	
	local xml, ctrl
	
	self.xml = CScriptXmlInit()
	xml = self.xml
	xml:ParseFile("ui_workshop.xml")
	
	self.ctrl = CUIWindow()
	ctrl = self.ctrl
	ctrl:SetAutoDelete(true)
	
	self.background    = xml:InitStatic("background", self)
	
	self.dialog	= xml:InitStatic("workshop:frame",self)
	
	self.cap_tab = xml:InitTextWnd("workshop:cap_tab" , self.dialog)
	self.info_ico = xml:InitStatic("workshop:pic_info" , self.dialog)
	
	ctrl = self.xml:Init3tButton("workshop:btn_state", self.dialog)
	self:Register(ctrl, "button_state")
	
	ctrl = self.xml:Init3tButton("workshop:btn_repair", self.dialog)
	self:Register(ctrl, "button_repair")
	
	ctrl = self.xml:Init3tButton("workshop:btn_upgrade", self.dialog)
	self:Register(ctrl, "button_upgrade")
	
	ctrl = self.xml:Init3tButton("workshop:btn_craft", self.dialog)
	self:Register(ctrl, "button_craft")
	
	self.dlg_state				= workshop_state_ui(xml, self, 0, 0, self.toolkits_state, self.toolkits_workshop)
	self.dlg_state:Show			(true)
	self.dialog:AttachChild		(self.dlg_state)
	xml:InitWindow				("tab_size", 0, self.dlg_state)
	
	self.dlg_repair				= workshop_repair_ui(xml, self, 0, 0, self.toolkits_state)
	self.dlg_repair:Show		(false)
	self.dialog:AttachChild		(self.dlg_repair)
	xml:InitWindow				("tab_size", 0, self.dlg_repair)
	
	self.dlg_upgrade			= workshop_upgrade_ui(xml, self, 0, 0, self.toolkits_state)
	self.dlg_upgrade:Show		(false)
	self.dialog:AttachChild		(self.dlg_upgrade)
	xml:InitWindow				("tab_size", 0, self.dlg_upgrade)
	
	self.dlg_craft				= workshop_craft_ui(xml, self, 0, 0, self.toolkits_state)
	self.dlg_craft:Show			(false)
	self.dialog:AttachChild		(self.dlg_craft)
	xml:InitWindow				("tab_size", 0, self.dlg_craft)
end

function workshop_ui:InitCallBacks()
	self:AddCallback("button_state",		ui_events.BUTTON_CLICKED,         self.OnButton_state,			self)
	self:AddCallback("button_repair",		ui_events.BUTTON_CLICKED,         self.OnButton_repair,			self)
	self:AddCallback("button_upgrade",		ui_events.BUTTON_CLICKED,         self.OnButton_upgrade,		self)
	self:AddCallback("button_craft",		ui_events.BUTTON_CLICKED,         self.OnButton_craft,			self)
end

function workshop_ui:Reset()
	if device():is_paused() then
		self.background:Show(true)
	else
		self.background:Show(false)
	end
end

function workshop_ui:OnButton_state()
	self.cap_tab:SetText(game.translate_string("st_tab_state"))
	self.dlg_state:Show			(true)
	self.dlg_repair:Show		(false)
	self.dlg_upgrade:Show		(false)
	self.dlg_craft:Show			(false)
end

function workshop_ui:OnButton_repair()
	self.cap_tab:SetText(game.translate_string("st_tab_repair"))
	self.dlg_state:Show			(false)
	self.dlg_repair:Show		(true)
	self.dlg_upgrade:Show		(false)
	self.dlg_craft:Show			(false)
end

function workshop_ui:OnButton_upgrade()
	self.cap_tab:SetText(game.translate_string("st_tab_upgrade"))
	self.dlg_state:Show			(false)
	self.dlg_repair:Show		(false)
	self.dlg_upgrade:Show		(true)
	self.dlg_craft:Show			(false)
end

function workshop_ui:OnButton_craft()
	self.cap_tab:SetText(game.translate_string("st_tab_craft"))
	self.dlg_state:Show			(false)
	self.dlg_repair:Show		(false)
	self.dlg_upgrade:Show		(false)
	self.dlg_craft:Show			(true)
end

function workshop_ui:OnButton_cancel()
	self.dlg_state:Show			(false)
	self.dlg_repair:Show		(false)
	self.dlg_upgrade:Show		(false)
	self.dlg_craft:Show			(false)
	self:OnCancel()
end

function workshop_ui:OnCancel()
	self:HideDialog()
	self:Show(false)
	
	if device():is_paused() then
		get_console():execute("main_menu off")
	end
end



--######################################################################################################################
--#															1. STATE													#
--######################################################################################################################

class "workshop_state_ui" (CUIScriptWnd)

function workshop_state_ui:__init(xml, owner, x, y, toolkits_state, toolkits_workshop) super(xml, owner, x, y, toolkits_state, toolkits_workshop)
	self.owner = owner
	self.xml = xml
	self.toolkits_state = toolkits_state or {}
	self.toolkits_workshop = toolkits_workshop or {}
	
	self:InitControls(x, y)
	self:InitCallBacks()
end

function workshop_state_ui:__finalize()
end


function workshop_state_ui:InitControls(x, y)
	local xml = self.xml
	
	self:SetWndPos(vector2():set(x,y))
	self:SetAutoDelete(true)

	self.btn_back = xml:Init3tButton("workshop:state:btn_back", self)
	self:Register(self.btn_back, "button_cancel")
	
	self.toolkit_b = {}
	self.toolkit_txt = {}
	self.toolkit_ico = {}
	self.toolkit_ico_temp = {}
	
	for i=1,#workshop_toolkits do
		self.toolkit_b[i] = xml:InitStatic("workshop:state:pic_toolkit_" .. tostring(i) .. "_b", self)
		self.toolkit_txt[i] = xml:InitTextWnd("workshop:state:txt_toolkit_" .. tostring(i), self)
		self.toolkit_ico[i] = xml:InitStatic("workshop:state:pic_toolkit_" .. tostring(i), self)
		
		local toolkit_sec = workshop_toolkits[i]
		local clr = clr_g
		local avail
		if self.toolkits_workshop[i] then
			self.toolkit_ico[i]:InitTexture("ui_inGame2_btn_workshop_toolkit_" .. tostring(i) .. "_h")
			avail = game.translate_string("st_itm_desc_state_avail_workshop")
		elseif self.toolkits_state[i] then
			self.toolkit_ico[i]:InitTexture("ui_inGame2_btn_workshop_toolkit_" .. tostring(i) .. "_h")
			avail = game.translate_string("st_itm_desc_state_avail")
		else
			self.toolkit_ico[i]:InitTexture("ui_inGame2_btn_workshop_toolkit_" .. tostring(i) .. "_d")
			clr = clr_r
			avail = game.translate_string("st_itm_desc_state_not_avail")
		end
		--self.toolkit_ico[i]::SetStretchTexture(true)
		local str = ui_item.get_sec_name(toolkit_sec) .. "\\n " .. clr .. avail
		
		self.toolkit_txt[i]:SetText(str)
	end
	
	self.info_text = xml:InitTextWnd("workshop:text_info" , self)
	
	local mech_name = game.translate_string("st_ui_workshop_owner_nobody")
	local str_intro = game.translate_string("st_ui_workshop_info_state_intro")
	local str_owner = game.translate_string("st_ui_workshop_owner")
	local mech_sec = self.owner.mechanic
	if mech_sec then
		local obj_mech = get_story_object(mech_sec)
		if obj_mech then
			mech_name = obj_mech:character_name()
		end
	end
	self.info_text:SetText( str_intro .. clr_b2 .. " \\n • " .. strformat(str_owner,mech_name) )
	
	--SetTip("state_intro", nil, nil, nil, true, self.info_text)
end

function workshop_state_ui:InitCallBacks()
	self:AddCallback("button_cancel",		ui_events.BUTTON_CLICKED,         self.OnButton_cancel,			self)
end

function workshop_state_ui:OnButton_cancel()
	self.owner:OnButton_cancel()
end


function workshop_state_ui:OnKeyboard(dik, keyboard_action)
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
			if dik == DIK_keys.DIK_ESCAPE then
				self:OnButton_cancel()
			end
		end
	end
	return res
end



--######################################################################################################################
--#															2. REPAIR													#
--######################################################################################################################

class "workshop_repair_ui" (CUIScriptWnd)

function workshop_repair_ui:__init(xml, owner, x, y, toolkits_state) super(xml, owner, x, y, toolkits_state)
	self.owner = owner
	self.xml = xml
	self.toolkits_state = toolkits_state or {}
	
	-- little trick to get clicked item from inv
	self.object = nil 
	self.object_part = nil
	self.selected_btn = nil
	self.highlight = nil
	self.highlight_part = nil
	self.highlight_btn = nil
	
	self.inv = {}
	self.inv_parts = {}
	
	self.parts = {} -- table of item parts section with their original condition, index is part number
	self.new_con = {} -- table of replacement item parts objects, index is part number
	
	self.toolkit = {}
	self.toolkit_inv = {}
	self.toolkit_pick = {}
	
	self:InitControls(x, y)
	self:InitCallBacks()
end

function workshop_repair_ui:__finalize()
end


function workshop_repair_ui:InitControls(x, y)
	local xml = self.xml

	self:SetWndPos(vector2():set(x,y))
	self:SetAutoDelete(true)

	xml:InitStatic("workshop:repair:cap_inv", self)
	xml:InitStatic("workshop:repair:cap_toolkit", self)
	xml:InitStatic("workshop:repair:cap_inv_parts", self)
	xml:InitStatic("workshop:repair:pic_inv_b", self)
	xml:InitStatic("workshop:repair:pic_inv_parts_b", self)
	
	self.dot = xml:InitStatic("workshop:repair:pic_c_dot", self)
	self.dot:Show(false)
	self.line_r = xml:InitStatic("workshop:repair:pic_c_line_r", self)
	self.line_r:Show(false)
	
	self.btn_back = xml:Init3tButton("workshop:repair:btn_back", self)
	self:Register(self.btn_back, "button_cancel")
	self.btn_back:Show(false)
	
	self.btn_repair = xml:Init3tButton("workshop:repair:btn_repair", self)
	self:Register(self.btn_repair, "button_repair")
	self.btn_repair:Enable(false)
	
	-- Repair parts
	self.itm_line = {}
	self.itm_b = {}
	self.itm_selected = {}
	self.itm_name = {}
	self.itm_con = {}
	self.itm_ico = {}
	self.itm_ico_temp = {}
	self.itm_btn = {}
	for i=1,6 do
		self.itm_line[i] = xml:InitStatic("workshop:repair:pic_c_line_" .. tostring(i) , self)
		self.itm_b[i] = xml:InitStatic("workshop:repair:pic_item_" .. tostring(i) .. "_b" , self)
		self.itm_selected[i] = xml:InitStatic("workshop:repair:pic_item_selected_" .. tostring(i) , self)
		self.itm_btn[i] = xml:Init3tButton("workshop:repair:inv_btn_part_" .. tostring(i) , self)
		self.itm_name[i] = xml:InitTextWnd("workshop:repair:text_item_" .. tostring(i) .. "_name" , self)
		self.itm_con[i] = xml:InitTextWnd("workshop:repair:text_item_" .. tostring(i) .. "_con" , self)
		self.itm_ico[i] = xml:InitStatic("workshop:repair:pic_item_" .. tostring(i) , self)
		self.itm_ico_temp[i] = xml:InitStatic("workshop:repair:pic_item_" .. tostring(i) , self)
		
		self.itm_line[i]:Show(false)
		self.itm_b[i]:Show(false)
		self.itm_btn[i]:Show(false)
		self:Register(self.itm_btn[i],"button_click_part")
	end
	
	-- Repair item
	self.itm_b_r = xml:InitStatic("workshop:repair:pic_item_r_b" , self)
	self.itm_b_r:Show(false)
	self.itm_ico_r = xml:InitStatic("workshop:repair:pic_item_r" , self)
	self.itm_ico_temp_r = xml:InitStatic("workshop:repair:pic_item_r" , self)
	self.itm_con_r = xml:InitTextWnd("workshop:repair:text_item_r_con" , self)
	
	-- Required toolkit
	self.itm_b_rq = xml:InitStatic("workshop:repair:pic_item_rq_b" , self)
	self.itm_ico_rq = xml:InitStatic("workshop:repair:pic_item_rq" , self)
	self.itm_ico_temp_rq = xml:InitStatic("workshop:repair:pic_item_rq" , self)
	self.itm_num_rq = xml:InitTextWnd("workshop:repair:text_item_rq_num" , self)
	
	self.info_text = xml:InitTextWnd("workshop:text_info" , self)
	
	self.scroll_inv = xml:InitScrollView("workshop:repair:scrollbar_inv", self)
	self.scroll_inv_parts = xml:InitScrollView("workshop:repair:scrollbar_inv_parts", self)
	
	self:InitInventory()
	
	-- Hint Window
	self.hint_wnd = xml:InitFrame("hint_wnd:background",self)
	self.hint_wnd:SetAutoDelete(false)
	self.hint_wnd_text = xml:InitTextWnd("hint_wnd:text",self.hint_wnd)
	self.hint_wnd:Show(false)
	
	-- Message Window 
	self.msg_wnd = xml:InitFrame("hint_wnd:background",self)
	self.msg_wnd:SetAutoDelete(false)
	self.msg_wnd_text = xml:InitTextWnd("hint_wnd:text",self.msg_wnd)
	self.msg_wnd_text:SetTextAlignment(2)
	
	self.msg_wnd:Show(false)
	self.msg_wnd:SetColor(GetARGB(255,0,0,0))
end

function workshop_repair_ui:InitCallBacks()
	self:AddCallback("button_cancel",		ui_events.BUTTON_CLICKED,         self.OnButton_cancel,			self)
	self:AddCallback("button_repair",		ui_events.BUTTON_CLICKED,         self.OnButton_repair,			self)
	
	self:AddCallback("button_inv",			ui_events.BUTTON_CLICKED,         self.OnButton_inv,			self)
	self:AddCallback("button_click_part",	ui_events.BUTTON_CLICKED,         self.OnButton_click_part,		self)
	self:AddCallback("button_inv_part",		ui_events.BUTTON_CLICKED,         self.OnButton_inv_part,		self)
end

function workshop_repair_ui:Update()
	CUIScriptWnd.Update(self)
	
	-- Warning messages timer 
	if (self.msg_wnd_timer and time_global() > self.msg_wnd_timer) then 
		self.msg_wnd_timer = nil
		self.msg_wnd:Show(false)
	end
	
	for k,v in pairs(self.inv_parts) do -- Must be first, cause all scroll elements of main inventory will be interactive even beyond scroll borders 
		if (v.btn and v.btn:IsCursorOverWindow()) then
			local obj = level.object_by_id(k)
			local name = ui_item.get_obj_name(obj)
			local desc = ui_item.get_obj_desc(obj)
			local str = "%c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc
			self:SetHint(str)
			self.highlight_part = obj
			return
		end
	end
	
	for k,v in pairs(self.inv) do 
		if (v.btn and v.btn:IsCursorOverWindow()) then
			local obj = level.object_by_id(k)
			local name = ui_item.get_obj_name(obj)
			local desc = ui_item.get_obj_desc(obj)
			local str = "%c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc
			self:SetHint(str)
			self.highlight = obj
			return
		end
	end
	
	for i=1,6 do 
		if self.parts[i] and self.parts[i].sec and (self.parts[i].sec ~= "na") and self.itm_ico[i]:IsCursorOverWindow() then
			local name = ui_item.get_sec_name(self.parts[i].sec)
			local desc = ui_item.get_sec_desc(self.parts[i].sec)
			local str = "%c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc
			self:SetHint(str)
			return
		end 
	end
	
	for i=1,6 do 
		if self.itm_btn[i] and self.itm_btn[i]:IsCursorOverWindow() then
			self.highlight_btn = i
			return
		end 
	end
	
	self.hint_wnd:Show(false)
end 

function workshop_repair_ui:SetMsg(text,tmr)
	if (text == "") then 
		return 
	end
	self.msg_wnd:Show(true)
	self.msg_wnd_text:SetText(text)
	self.msg_wnd_text:AdjustHeightToText()
	self.msg_wnd_text:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+10))
	self.msg_wnd_text:SetWndPos(vector2():set(0,20))
	
	self.msg_wnd:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+44))
	self.msg_wnd:SetWndPos(vector2():set(0,80))

	self.msg_wnd_timer = time_global() + 1000*tmr
end

function workshop_repair_ui:SetHint(text,pos)
	if (text == "") then
		return
	end
	self.hint_wnd:Show(true)
	self.hint_wnd_text:SetText(text)
	self.hint_wnd_text:AdjustHeightToText()
	self.hint_wnd:SetWndSize(vector2():set(self.hint_wnd:GetWidth(),self.hint_wnd_text:GetHeight()+44))
	
	pos = pos or GetCursorPosition()
	pos.y = pos.y - self.hint_wnd:GetHeight()
	pos.x = pos.x - self.hint_wnd:GetWidth()
	self.hint_wnd:SetWndPos(pos)
	
	FitInRect(self.hint_wnd,Frect():set(0,0,1024,768),0,100)
end


function workshop_repair_ui:InitInventory()
	local xml = self.xml
	local inv = {}

	local function search(temp, obj)
		local sec = obj:section()
		sec = ini_sys:r_string_ex(sec,"parent_section") or sec -- for weapons with scopes
		if ini_parts:r_string_ex("con_parts_list",sec) then
			local con = math.ceil(obj:condition()*100)
			local w = ini_sys:r_float_ex(sec,"inv_grid_width")
			local h = ini_sys:r_float_ex(sec,"inv_grid_height")
			inv[obj:id()] = { sec = sec , con = con , w = w , h = h }
		end
	end
	db.actor:iterate_inventory(search,nil)
	
	local function count_grids_num(t)
		local cnt = 0
		for _,v in pairs(t) do
			cnt = cnt + (v.w * v.h)
		end
		return cnt
	end
	
	empty_table(self.inv)
	self.scroll_inv:Clear()
	local _st = xml:InitStatic("workshop:repair:pic_inv_form", nil)
	
	local grid = xml:InitStatic("inv_grid", nil)
	local grid_w = grid:GetWidth()
	local grid_h = grid:GetHeight()
	local tot_grid_w = math.floor(_st:GetWidth() / grid_w)
	local tot_grid_h = math.floor(_st:GetHeight() / grid_h)
	local tot_grid_num = math.max( count_grids_num(inv) , (tot_grid_w * tot_grid_h))
	local tot_grid_ind = {}
	for i=1,tot_grid_num do
		local row = mc(i/tot_grid_w)
		tot_grid_ind[row] = tot_grid_ind[row] or {}
		tot_grid_ind[row][#tot_grid_ind[row] + 1] = true
	end

	for k,v in pairs(inv) do
		self.inv[k] = {}
		self.inv[k].ico_tmp = xml:InitStatic("inv_grid", _st)
		self.inv[k].btn = xml:Init3tButton("inv_btn_" .. tostring(v.w) .. "_" .. tostring(v.h), _st)
		self.inv[k].ico = xml:InitStatic("inv_grid", _st)
		self.inv[k].ico_s = xml:InitStatic("inv_grid", _st)
		self.inv[k].txt = xml:InitTextWnd("inv_text", _st)
		
		tot_grid_h = txr_utils.set_grid_element(
			{ id = k , sec = v.sec , g_w = grid_w , g_h = grid_h , w = v.w , h = v.h , g_row = tot_grid_w },
			tot_grid_ind,
			self.inv[k].btn, self.inv[k].ico, self.inv[k].ico_s, self.inv[k].ico_tmp, self.inv[k].txt
		)
		txr_utils.set_up_icon(v.sec, nil, self.inv[k].ico_tmp, self.inv[k].ico, self.inv[k].ico_s)
		self:Register(self.inv[k].btn, "button_inv")
		
		--txr_utils.adjust_size_to_element(self.inv[k].btn, 0, 0, self.inv[k].txt)
		local clr = txr_utils.get_con_clr(v.con)
		self.inv[k].txt:SetText(clr .. v.con)
		
	end
	
	_st:SetWndSize(vector2():set(_st:GetWidth(),tot_grid_h * grid_h))
	self.scroll_inv:AddWindow(_st, true)
	_st:SetAutoDelete(false)
	
	SetTip("repair_intro", nil, nil, nil, true, self.info_text)
end

function workshop_repair_ui:InitInventoryParts(sec_part, con_part)
	local xml = self.xml
	local inv = {}

	local function search(temp, obj)
		local sec = obj:section()
		if (sec == sec_part) then
			local con = math.ceil(obj:condition()*100)
			local w = ini_sys:r_float_ex(sec,"inv_grid_width")
			local h = ini_sys:r_float_ex(sec,"inv_grid_height")
			inv[obj:id()] = { con = con , w = w , h = h }
		end
	end
	db.actor:iterate_inventory(search,nil)
	
	local function count_grids_num(t)
		local cnt = 0
		for _,v in pairs(t) do
			cnt = cnt + (v.w * v.h)
		end
		return cnt
	end
	
	local pst = false
	empty_table(self.inv_parts)
	self.scroll_inv_parts:Clear()
	local _st = xml:InitStatic("workshop:repair:pic_inv_parts_form", nil)
	
	local grid = xml:InitStatic("inv_grid", nil)
	local grid_w = grid:GetWidth()
	local grid_h = grid:GetHeight()
	local tot_grid_w = math.floor(_st:GetWidth() / grid_w)
	local tot_grid_h = math.floor(_st:GetHeight() / grid_h)
	local tot_grid_num = math.max( count_grids_num(inv) , (tot_grid_w * tot_grid_h))
	local tot_grid_ind = {}
	for i=1,tot_grid_num do
		local row = mc(i/tot_grid_w)
		tot_grid_ind[row] = tot_grid_ind[row] or {}
		tot_grid_ind[row][#tot_grid_ind[row] + 1] = true
	end
	
	for k,v in pairs(inv) do
		self.inv_parts[k] = {}
		self.inv_parts[k].ico_tmp = xml:InitStatic("inv_grid", _st)
		self.inv_parts[k].btn = xml:Init3tButton("inv_btn_" .. tostring(v.w) .. "_" .. tostring(v.h), _st)
		self.inv_parts[k].ico = xml:InitStatic("inv_grid", _st)
		self.inv_parts[k].ico_s = xml:InitStatic("inv_grid", _st)
		self.inv_parts[k].txt = xml:InitTextWnd("inv_text", _st)
		
		tot_grid_h = txr_utils.set_grid_element(
			{ id = k , sec = sec_part , g_w = grid_w , g_h = grid_h , w = v.w , h = v.h , g_row = tot_grid_w },
			tot_grid_ind,
			self.inv_parts[k].btn, self.inv_parts[k].ico, self.inv_parts[k].ico_s, self.inv_parts[k].ico_tmp, self.inv_parts[k].txt
		)
		txr_utils.set_up_icon(sec_part, v.con <= con_part, self.inv_parts[k].ico_tmp, self.inv_parts[k].ico, self.inv_parts[k].ico_s)
		
		if v.con <= con_part then
			self.inv_parts[k].btn:Show(false)
		else
			self:Register(self.inv_parts[k].btn, "button_inv_part")
			pst = true
		end
		
		--txr_utils.adjust_size_to_element(self.inv_parts[k].btn, 0, 0, self.inv_parts[k].txt)
		local clr = txr_utils.get_con_clr(v.con)
		self.inv_parts[k].txt:SetText(clr .. v.con)
		
	end
	
	_st:SetWndSize(vector2():set(_st:GetWidth(),tot_grid_h * grid_h))
	self.scroll_inv_parts:AddWindow(_st, true)
	_st:SetAutoDelete(false)
	
	SetTip("repair_tip_3", "repair_warning_3", "repair_solution_3", sec_part, pst, self.info_text)
end


function workshop_repair_ui:OnButton_inv() -- upon clicking on inv item
	if self.highlight then
		self.object = self.highlight
		
		-- Reset
		empty_table(self.new_con)
		empty_table(self.inv_parts)
		empty_table(self.parts)
		self.object_part = nil
		self.selected_btn = nil
		self.highlight_part = nil
		self.highlight_btn = nil
		self.scroll_inv_parts:Clear()
		local ps_cnt = 0
		
		--self.dot:Show(true)
		--self.line_r:Show(true)
		self.itm_b_r:Show(true)
		
		txr_sounds.actor_on_item_take(self.object)
	
		local sec = self.object:section()
		sec = ini_sys:r_string_ex(sec,"parent_section") or sec -- for weapons with scopes
		local con = math.ceil(100*(self.object:condition()))
		txr_utils.set_up_upgr_icon(self.object, sec, self.itm_ico_r, self.itm_ico_temp_r)
		self.itm_con_r:SetText(con .. "%")
		
		-- Prepare toolkit
		local toolkits_num = self:UpdateToolkits(0)
		
		-- Prepare parts
		local parts = ini_parts:r_string_ex("con_parts_list",sec)
		parts = parts and alun_utils.str_explode(parts,",") or {}
		local parts_con = txr_condition.get_parts_con(self.object, nil, true)
		for i=1,#parts do
			self.parts[i] = {}
			self.parts[i].sec = parts[i]
			self.parts[i].con = parts_con[parts[i]]
		end
		
		for i=1,6 do
			if self.parts[i] and self.parts[i].sec and (self.parts[i].sec ~= "na") and self.parts[i].con then
				local part_name = ui_item.get_sec_name(self.parts[i].sec) or ""
				local con = txr_utils.get_static_cond(self.parts[i].con)
				local clr = txr_utils.get_con_clr(con)
				local obj_part = db.actor:object(self.parts[i].sec)
				--self.itm_line[i]:Show(true)
				self.itm_b[i]:Show(true)
				self.itm_selected[i]:InitTexture("ui_button_inv_d")
				self.itm_selected[i]:Show(true)
				self.itm_btn[i]:Show(obj_part and (toolkits_num > 0) and true or false)
				self.itm_name[i]:SetText(part_name)
				self.itm_con[i]:SetText(clr .. con .. "%")
				txr_utils.set_up_icon(self.parts[i].sec, obj_part == nil, self.itm_ico_temp[i], self.itm_ico[i])
				ps_cnt = ps_cnt + (obj_part and 1 or 0)
			else
				self.itm_line[i]:Show(false)
				self.itm_b[i]:Show(false)
				self.itm_selected[i]:Show(false)
				self.itm_btn[i]:Show(false)
				self.itm_name[i]:SetText("")
				self.itm_con[i]:SetText("")
				self.itm_ico[i]:InitTexture("ui_button_inv_d")
			end
		end
		
		if (toolkits_num > 0) then
			SetTip("repair_tip_1", "repair_warning_1", "repair_solution_1", self.toolkit, (ps_cnt == #self.parts), self.info_text)
		else
			SetTip("repair_tip_1", "repair_warning_2", "repair_solution_2", self.toolkit, false, self.info_text)
		end
	end
end

function workshop_repair_ui:OnButton_inv_part()  -- upon clicking on inv part item
	if self.highlight_part and self.selected_btn then
		self.object_part = self.highlight_part
		self.itm_selected[self.selected_btn]:InitTexture("ui_button_inv_t")
			
		print_ws("- workshop_repair_ui:OnButton_inv_part() | picked replacement part (%s) [%s] - condition: %s", self.object_part:id(), self.object_part:section(), self.object_part:condition())
		
		-- Save the condition of selected part
		local new_part_con = math.ceil(self.object_part:condition()*100)
		
		self.new_con[self.selected_btn] = {}
		self.new_con[self.selected_btn].id = self.object_part:id()
		self.new_con[self.selected_btn].con = new_part_con
	
		-- Calculate individual condition and update text
		self.btn_repair:Enable(true)
		local tot_con = 0
		local cnt = 0
		local active = 0
		for i=1,6 do
			if self.parts[i] and self.parts[i].sec and (self.parts[i].sec ~= "na") then
				local t = self.parts[i].con
				if self.new_con[i] then
					t = self.new_con[i].con
					active = active + 1
				end
				local clr = txr_utils.get_con_clr(t)
				self.itm_con[i]:SetText(clr .. t .. "%")
				tot_con = tot_con + t --AdjustCon(self.parts[i].sec, t, #self.parts, IsOutfit(self.object))
				cnt = cnt + 1
			end
		end
		
		-- Calculate total condition and update text
		tot_con = utils.clamp(math.ceil(tot_con/cnt),0,100)
		self.itm_con_r:SetText(tot_con .. "%")
		
		-- Update remaining toolkit count
		self:UpdateToolkits(active)
		
		-- Hide part inventory
		empty_table(self.inv_parts)
		self.scroll_inv_parts:Clear()
		
		txr_utils.play_sound("interface\\items\\inv_items_cloth_" .. tostring(math.random(2,3)))
		
		SetTip("repair_tip_4", nil, nil, nil, true, self.info_text)
		
		-- Reset
		self.object_part = nil
		self.selected_btn = nil
		self.highlight_part = nil
		self.highlight_btn = nil
	end
end

function workshop_repair_ui:OnButton_click_part()
	if self.highlight_btn then
		self.selected_btn = self.highlight_btn
		local sec_part = self.parts[self.selected_btn].sec
		local con_part = self.parts[self.selected_btn].con
		self:InitInventoryParts(sec_part, con_part)
	end
end

function workshop_repair_ui:UpdateToolkits(num)
	empty_table(self.toolkit_inv)
	empty_table(self.toolkit_pick)
	local toolkits_num = 0
	self.toolkit = "na"
	local main_sec = self.object:section()
	local repair_type = ini_sys:r_string_ex(main_sec,"repair_type") or main_sec
	for k,v in pairs(itms_manager.itms_workshop_tools) do
		if v[repair_type] then
			self.toolkit = k
			print_ws("- workshop_repair_ui:UpdateToolkits(%s) | picked proper tookit [%s] to use for [%s]", num, k, main_sec)
			break
		end
	end
	if self.toolkit then
		self.toolkit_inv = itms_manager.collect_avail_item_uses(db.actor, self.toolkit)
		for _,uses in pairs(self.toolkit_inv) do
			toolkits_num = toolkits_num + uses
		end
		
		if (num > 0) then
			for i=1,num do
				local id = random_key_table(self.toolkit_inv)
				local uses = self.toolkit_inv[id]
				if uses and uses > 0 then
					uses = uses - 1
					self.toolkit_pick[#self.toolkit_pick + 1] = id
					if uses == 0 then
						self.toolkit_inv[id] = nil
					else
						self.toolkit_inv[id] = uses
					end
				end
			end
		end
		
		local toolkits_remain = toolkits_num - #self.toolkit_pick
		for i=1,6 do
			if self.parts[i] and self.parts[i].sec and (not self.new_con[i]) then
				if (toolkits_remain < 1) then
					self.itm_btn[i]:Enable(false)
				else
					self.itm_btn[i]:Enable(true)
				end
			end
		end
		
		txr_utils.set_up_icon(self.toolkit, toolkits_remain < 1, self.itm_ico_temp_rq, self.itm_ico_rq)
		self.itm_num_rq:SetText((toolkits_remain > 0 and clr_g or clr_r) .. tostring(toolkits_remain))
		
		return toolkits_remain
	else
		printf("! workshop_repair_ui:UpdateToolkits(%s) | no proper repair toolkit is found for item [%s], make sure it is supported by repair tools sections", num, main_sec)
	end
	return 0
end


function workshop_repair_ui:OnButton_cancel()
	self.owner:OnButton_cancel()
end

function workshop_repair_ui:OnButton_repair()
	local sim = alife()
	local tot_con = 0
	local cnt = 0
	if size_table(self.new_con) > 0 then
		for i=1,6 do
			if self.parts[i] and self.parts[i].sec and (self.parts[i].sec ~= "na") then
				if self.new_con[i] and self.new_con[i].id then
					self.parts[i].con = self.new_con[i].con
					print_ws("- workshop_repair_ui:OnButton_repair() | replaced part spotted | part: %s - condition: %s - order: %s - id: %s", self.parts[i].sec, self.new_con[i].con, i, self.new_con[i].id)
					
					-- Release replacement parts
					local se_obj_part = alife_object(self.new_con[i].id)
					if se_obj_part then
						sim:release(se_obj_part,true)
					else
						printf("!ERROR workshop_repair_ui:OnButton_repair() | can't release replacment part (%s)", self.new_con[i].id)
					end
				end
				
				tot_con = tot_con + self.parts[i].con --AdjustCon(self.parts[i].sec, self.parts[i].con, #self.parts, IsOutfit(self.object))
				cnt = cnt + 1
				print_ws("/ workshop_repair_ui:OnButton_repair() | total condition calculation | part: %s - condition: %s - order: %s - total sum: %s", self.parts[i].sec, self.parts[i].con, i, tot_con)
			end
		end
	else
		print_ws("! workshop_repair_ui:OnButton_repair() | no new parts have been replaced")
		return
	end
	
	-- Discharge tools
	for i=1,#self.toolkit_pick do
		local obj = level.object_by_id(self.toolkit_pick[i])
		if obj then
			itms_manager.discharge(obj)
			print_ws("/ workshop_repair_ui:OnButton_repair() | discharged toolkit (%s)", self.toolkit_pick[i])
		else
			printf("!ERROR workshop_repair_ui:OnButton_repair() | can't discharge toolkit with id (%s). Object not found!", self.toolkit_pick[i])
		end
	end
	
	-- Apply condition changes
	local id = self.object:id()
	local sec = self.object:section()
	sec = ini_sys:r_string_ex(sec,"parent_section") or sec -- for weapons with scopes
	
	local final_con = (cnt > 0) and (utils.clamp(math.ceil(tot_con/cnt),1,100)/100)
	local weapon = level.object_by_id(id)
	if weapon and final_con and (final_con >= 0) and (final_con <= 1) then
		weapon:set_condition(final_con)
		print_ws("- workshop_repair_ui:OnButton_repair() | object with id (%s) is set to a new condition: %s", id, final_con)
	else
		printf("! workshop_repair_ui:OnButton_repair() | object with id (%s) is either not found. Or didn't register new condition (%s)!", id, final_con)
	end
	
	local result_part_tbl = {}
	result_part_tbl[sec] = math.ceil(tot_con/cnt)
	for i=1,#self.parts do
		result_part_tbl[self.parts[i].sec] = self.parts[i].con
	end
	txr_condition.set_parts_con(id, result_part_tbl)
	
	for k,v in pairs(result_part_tbl) do
		print_ws("~ workshop_repair_ui:OnButton_repair() | item's new part table [%s] = %s",k,v)
	end
	
	-- Effect
	txr_actor_effects.play_item_fx("craft_dummy")

	self:OnButton_cancel()
end


function workshop_repair_ui:OnKeyboard(dik, keyboard_action)
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
			if dik == DIK_keys.DIK_ESCAPE then
				self:OnButton_cancel()
			end
		end
	end
	return res
end



--######################################################################################################################
--#															3. UPGRADE													#
--######################################################################################################################

class "workshop_upgrade_ui" (CUIScriptWnd)

function workshop_upgrade_ui:__init(xml, owner, x, y, toolkits_state) super(xml, owner, x, y, toolkits_state)
	self.owner = owner
	self.xml = xml
	self.toolkits_state = toolkits_state or {}
		
	self.object = nil
	self.highlight = nil
	self.step = 0
	self.update_cache = {}
	self.last_upgr = {}
	
	self.inst_upgr = {}
	self.inst_upgr_xml = {}
	
	self.inv = {}
	self.upgr = {} -- upgr[group][index] = {name, desc, icon, part}
	self.upgr_xml = {}
	self.upgr_idx = {}
	self.upgr_tools = {}
	self.upgr_tools_pick = {}
	self.upgr_toolkit = nil
	self.upgr_flags = {}
	
	self:InitControls(x, y)
	self:InitCallBacks()
end

function workshop_upgrade_ui:__finalize()
end


function workshop_upgrade_ui:InitControls(x, y)
	local xml = self.xml

	self:SetWndPos(vector2():set(x,y))
	self:SetAutoDelete(true)

	-- Base
	xml:InitStatic("workshop:upgrade:cap_inv", self)
	xml:InitStatic("workshop:upgrade:cap_upgrades", self)
	
	xml:InitStatic("workshop:upgrade:pic_inv_b", self)
	xml:InitStatic("workshop:upgrade:pic_upgr_menu_b", self)
	xml:InitStatic("workshop:upgrade:pic_item_r_b", self)
	
	xml:InitStatic("workshop:upgrade:pic_c_line_1", self)
	--xml:InitStatic("workshop:upgrade:pic_c_line_2", self)
	xml:InitStatic("workshop:upgrade:pic_c_line_3", self)
	--xml:InitStatic("workshop:upgrade:pic_c_line_4", self)
	
	self.btn_back = xml:Init3tButton("workshop:upgrade:btn_back", self)
	self:Register(self.btn_back, "button_cancel")
	self.btn_back:Show(false)
	
	self.btn_upgrade = xml:Init3tButton("workshop:upgrade:btn_upgrade", self)
	self:Register(self.btn_upgrade, "button_upgrade")
	self.btn_upgrade:Enable(false)
	
	-- Object
	self.itm_ico_r = xml:InitStatic("workshop:upgrade:pic_item_r" , self)
	self.itm_ico_temp_r = xml:InitStatic("workshop:upgrade:pic_item_r" , self)
	
	-- Required tookit
	self.itm_cap_rq = xml:InitStatic("workshop:upgrade:cap_toolkit" , self)
	self.itm_b_rq = xml:InitStatic("workshop:upgrade:pic_item_rq_b" , self)
	self.itm_ico_rq = xml:InitStatic("workshop:upgrade:pic_item_rq" , self)
	self.itm_ico_temp_rq = xml:InitStatic("workshop:upgrade:pic_item_rq" , self)
	self.itm_num_rq = xml:InitTextWnd("workshop:upgrade:text_item_rq_num" , self)
	
	self.info_text = xml:InitTextWnd("workshop:text_info" , self)
	
	-- Scrolls
	self.scroll_inv = xml:InitScrollView("workshop:upgrade:scrollbar_inv", self)
	self.scroll_upgr = xml:InitScrollView("workshop:upgrade:scrollbar_upgr", self)
	
	self:InitInventory()
	
	-- Hint Window
	self.hint_wnd = xml:InitFrame("hint_wnd:background",self)
	self.hint_wnd:SetAutoDelete(false)
	self.hint_wnd_text = xml:InitTextWnd("hint_wnd:text",self.hint_wnd)
	self.hint_wnd:Show(false)
	
	-- Message Window 
	self.msg_wnd = xml:InitFrame("hint_wnd:background",self)
	self.msg_wnd:SetAutoDelete(false)
	self.msg_wnd_text = xml:InitTextWnd("hint_wnd:text",self.msg_wnd)
	self.msg_wnd_text:SetTextAlignment(2)
	
	self.msg_wnd:Show(false)
	self.msg_wnd:SetColor(GetARGB(255,0,0,0))
end

function workshop_upgrade_ui:InitCallBacks()
	self:AddCallback("button_cancel",		ui_events.BUTTON_CLICKED,         self.OnButton_cancel,			self)
	self:AddCallback("button_upgrade",		ui_events.BUTTON_CLICKED,         self.OnButton_upgrade,		self)

	self:AddCallback("button_inv",			ui_events.BUTTON_CLICKED,         self.OnButton_inv,			self)
	self:AddCallback("check_upgrade", 		ui_events.BUTTON_CLICKED, 			self.OnCheck_Upgrade, 		self)
end

function workshop_upgrade_ui:Update()
	CUIScriptWnd.Update(self)
	
	-- Warning messages timer 
	if (self.msg_wnd_timer and time_global() > self.msg_wnd_timer) then 
		self.msg_wnd_timer = nil
		self.msg_wnd:Show(false)
	end
	
	for k,v in pairs(self.inv) do 
		if (v.btn and v.btn:IsCursorOverWindow()) then
			self.update_cache["type"] = 1 -- reset cache
			local obj = level.object_by_id(k)
			local name = ui_item.get_obj_name(obj)
			local desc = ui_item.get_obj_desc(obj)
			local str = "%c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc
			self:SetHint(str)
			self.highlight = obj
			return
		end
	end
	
	for k1,v1 in pairs(self.upgr_xml) do  
		for k2,v2 in pairs(v1) do
			if v2.pic:IsCursorOverWindow() and self.upgr[k1][k2] then
				-- Cache
				if (self.update_cache["type"] == 2) and (self.update_cache["k1"] == k1) and (self.update_cache["k2"] == k2) then
					self:SetHint(self.update_cache["str"])
					self.last_upgr = {k1,k2}
					return
				end
			
				local str = ""
				local name = game.translate_string(self.upgr[k1][k2].name)
				local desc = game.translate_string(self.upgr[k1][k2].desc)
				
				local t = self.upgr_flags[k1][k2]
				for i=1,#t do
					if (not t[i]) then
						local s = game.translate_string("st_ui_workshop_no_upgr_" .. tostring(i))
						if (i == 1) then
							local main_tool = self.upgr_toolkit or ""
							s = strformat(s, ui_item.get_sec_name(main_tool))
						elseif (i == 2) then
							local tool = self.upgr[k1][k2].tool or ""
							s = strformat(s, ui_item.get_sec_name(tool))
						end
						str = clr_r .. " • " .. s .. "\\n " .. str
					end
				end
				
				str = str .. "\\n %c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc .. "\\n \\n"
				
				local sec = self.upgr[k1][k2].sec
				local prop = self.upgr[k1][k2].prop
				for i=1,#prop do
					local prop_func = ini_upgr_props:r_string_ex(prop[i],"functor")
					if prop_func == "inventory_upgrades.property_functor_a" then
						str = str .. "\\n " .. clr_b1 .. " • " .. inventory_upgrades.property_functor_a(sec,prop[i])
					elseif prop_func == "inventory_upgrades.property_functor_b" then
						str = str .. "\\n " .. clr_b1 .. " • " .. inventory_upgrades.property_functor_b(sec,prop[i])
					elseif prop_func == "inventory_upgrades.property_functor_c" then
						str = str .. "\\n " .. clr_b1 .. " • " .. inventory_upgrades.property_functor_c(sec,prop[i])
					elseif prop_func == "inventory_upgrades.property_functor_d" then
						str = str .. "\\n " .. clr_b1 .. " • " .. inventory_upgrades.property_functor_d(sec,prop[i])
					elseif prop_func == "inventory_upgrades.property_functor_t" then
						str = str .. "\\n " .. clr_b1 .. " • " .. inventory_upgrades.property_functor_t(sec,prop[i])
					end
				end
				
				-- Cache
				self.update_cache["type"] = 2
				self.update_cache["k1"] = k1
				self.update_cache["k2"] = k2
				self.update_cache["str"] = str
				
				self:SetHint(str)
				self.last_upgr = {k1,k2}
				return
			elseif v2.itm:IsCursorOverWindow() and self.upgr[k1][k2] then
				self.update_cache["type"] = 3 -- reset cache
				local tool = self.upgr[k1][k2].tool
				if tool then
					local name = ui_item.get_sec_name(tool)
					local desc = ui_item.get_sec_desc(tool)
					local str = "%c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc
					self:SetHint(str)
					return
				end
			end
		end
	end
	
	if self.itm_ico_rq:IsCursorOverWindow() and self.upgr_toolkit then
		self.update_cache["type"] = 4 -- reset cache
		local name = ui_item.get_sec_name(self.upgr_toolkit)
		local desc = ui_item.get_sec_desc(self.upgr_toolkit)
		local str = "%c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc
		self:SetHint(str)
		return
	end
	
	self.hint_wnd:Show(false)
end 

function workshop_upgrade_ui:SetMsg(text,tmr)
	if (text == "") then 
		return 
	end
	self.msg_wnd:Show(true)
	self.msg_wnd_text:SetText(text)
	self.msg_wnd_text:AdjustHeightToText()
	self.msg_wnd_text:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+10))
	self.msg_wnd_text:SetWndPos(vector2():set(0,20))
	
	self.msg_wnd:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+44))
	self.msg_wnd:SetWndPos(vector2():set(0,80))

	self.msg_wnd_timer = time_global() + 1000*tmr
end

function workshop_upgrade_ui:SetHint(text,pos)
	if (text == "") then
		return
	end
	self.hint_wnd:Show(true)
	self.hint_wnd_text:SetText(text)
	self.hint_wnd_text:AdjustHeightToText()
	self.hint_wnd:SetWndSize(vector2():set(self.hint_wnd:GetWidth(),self.hint_wnd_text:GetHeight()+44))
	
	pos = pos or GetCursorPosition()
	pos.y = pos.y - self.hint_wnd:GetHeight()
	pos.x = pos.x - self.hint_wnd:GetWidth()
	self.hint_wnd:SetWndPos(pos)
	
	FitInRect(self.hint_wnd,Frect():set(0,0,1024,768),0,100)
end


function workshop_upgrade_ui:OnButton_inv()
	if self.highlight then
		
		-- reset
		self.object = self.highlight
		empty_table(self.inst_upgr)
		empty_table(self.inst_upgr_xml)
		empty_table(self.upgr_tools)
		empty_table(self.upgr_tools_pick)
		self.last_upgr = {}
		self.step = 0
		empty_table(self.update_cache)
		self.btn_upgrade:Enable(false)
		
		txr_sounds.actor_on_item_take(self.object)

		local obj = self.object
		local se_obj = obj and alife_object(obj:id())
		if se_obj then
			local data = IsWeapon(obj) and stpk_utils.get_weapon_data(se_obj) or stpk_utils.get_item_data(se_obj)
			copy_table(self.inst_upgr, data.upgrades)
			t2k_table(self.inst_upgr)
			
			-- Pre-installed upgrades
			local pre_installed = ini_sys:r_string_ex(obj:section(),"installed_upgrades")
			if pre_installed and pre_installed ~= "" then
				local t = alun_utils.str_explode(pre_installed,",")
				for i=1,#t do
					self.inst_upgr[t[i]] = true
				end
			end
			
		else
			return
		end
		
		self.upgr_toolkit = "na"
		local main_sec = obj:section()
		local repair_type = ini_sys:r_string_ex(main_sec,"repair_type") or main_sec
		for k,v in pairs(itms_manager.itms_workshop_tools) do
			if v[repair_type] then
				self.upgr_toolkit = k
				break
			end
		end
		if self.upgr_toolkit == "na" then
			printf("! Workshop UI | no proper repair toolkit is found for item [%s], make sure it is supported by repair tools sections", main_sec)
		end
		
		local function search(temp, obj)
			local sec = obj:section()
			if itms_manager.itms_upgrades[sec] or (sec == self.upgr_toolkit) then
				if (not self.upgr_tools[sec]) then
					self.upgr_tools[sec] = {}
				end
				local uses = itms_manager.get_item_remaining_uses(obj)
				self.upgr_tools[sec][obj:id()] = uses
				--printf("-self.upgr_tools[%s][%s] = %s",sec,obj:id(),uses)
			end
		end
		if self.owner.dbg then
			self.upgr_tools[self.upgr_toolkit] = {}
			self.upgr_tools[self.upgr_toolkit][0] = 999
			for sec,_ in pairs(itms_manager.itms_upgrades) do
				self.upgr_tools[sec] = {}
				self.upgr_tools[sec][0] = 999
			end
		else
			db.actor:iterate_inventory(search,nil)
		end
		
		self:InitUpgradeTree()
		self:EvaluateUpgrades()
		
	end
end

function workshop_upgrade_ui:OnCheck_Upgrade()
	self:EvaluateUpgrades()
end

function workshop_upgrade_ui:InitInventory()
	local xml = self.xml
	local inv = {}

	local function search(temp, obj)
		local sec = obj:section()
		local upgr_list = ini_sys:r_string_ex(sec,"upgrades")
		if upgr_list and (upgr_list ~= "") then
			local w = ini_sys:r_float_ex(sec,"inv_grid_width")
			local h = ini_sys:r_float_ex(sec,"inv_grid_height")
			inv[obj:id()] = { sec = sec , w = w , h = h }
		end
	end
	db.actor:iterate_inventory(search,nil)
	
	local function count_grids_num(t)
		local cnt = 0
		for _,v in pairs(t) do
			cnt = cnt + (v.w * v.h)
		end
		return cnt
	end
	
	empty_table(self.inv)
	self.scroll_inv:Clear()
	local _st = xml:InitStatic("workshop:upgrade:pic_inv_form", nil)
	
	local grid = xml:InitStatic("inv_grid", nil)
	local grid_w = grid:GetWidth()
	local grid_h = grid:GetHeight()
	local tot_grid_w = math.floor(_st:GetWidth() / grid_w)
	local tot_grid_h = math.floor(_st:GetHeight() / grid_h)
	local tot_grid_num = math.max( count_grids_num(inv) , (tot_grid_w * tot_grid_h))
	local tot_grid_ind = {}
	for i=1,tot_grid_num do
		local row = mc(i/tot_grid_w)
		tot_grid_ind[row] = tot_grid_ind[row] or {}
		tot_grid_ind[row][#tot_grid_ind[row] + 1] = true
	end
	--printf("-Workshop UI | total grid number: %s , grid coloumns: %s , one grid width: %s , one grid height: %s", tot_grid_num, tot_grid_w, grid_w, grid_h)
	
	for k,v in pairs(inv) do
		--printf("-Workshop UI | scan item (%s) [%s]", k, v.sec)
		self.inv[k] = {}
		self.inv[k].ico_tmp = xml:InitStatic("inv_grid", _st)
		self.inv[k].btn = xml:Init3tButton("inv_btn_" .. tostring(v.w) .. "_" .. tostring(v.h), _st)
		self.inv[k].ico = xml:InitStatic("inv_grid", _st)
		self.inv[k].ico_s = xml:InitStatic("inv_grid", _st)
		
		tot_grid_h = txr_utils.set_grid_element(
			{ id = k , sec = v.sec , g_w = grid_w , g_h = grid_h , w = v.w , h = v.h , g_row = tot_grid_w },
			tot_grid_ind,
			self.inv[k].btn, self.inv[k].ico, self.inv[k].ico_s, self.inv[k].ico_tmp
		)
		txr_utils.set_up_icon(v.sec, nil, self.inv[k].ico_tmp, self.inv[k].ico, self.inv[k].ico_s)
		self:Register(self.inv[k].btn, "button_inv")
	end
	
	_st:SetWndSize(vector2():set(_st:GetWidth(),tot_grid_h * grid_h))
	self.scroll_inv:AddWindow(_st, true)
	_st:SetAutoDelete(false)
	
	SetTip("upgrade_intro", nil, nil, nil, true, self.info_text)
end

function workshop_upgrade_ui:InitUpgradeTree()
	local xml = self.xml
	local sec = self.object:section()
	
	self.scroll_upgr:Clear()
	
	txr_utils.set_up_upgr_icon(self.object, sec, self.itm_ico_r, self.itm_ico_temp_r)
	
	-- Init main tool ico + num
	local cnt = 0
	if self.upgr_tools[self.upgr_toolkit] then
		for id,v in pairs(self.upgr_tools[self.upgr_toolkit]) do
			cnt = cnt + v
		end
	end
	txr_utils.set_up_icon(self.upgr_toolkit, cnt == 0, self.itm_ico_temp_rq, self.itm_ico_rq)
	self.itm_num_rq:SetText(tostring(cnt))
	
	local upgrades = txr_utils.extract_var(ini_sys,sec,"upgrades",1)
	if upgrades and (#upgrades > 0) then
		empty_table(self.upgr) 
		for i=1, #upgrades do
			txr_utils.extract_upgr(self.upgr, upgrades[i])
		end
		--[[
		for k,v in pairs(self.upgr) do
			for k2,v2 in pairs(v) do
				printf("- upgrade table group[%s] index[%s] = %s",k,k2,v2)
			end
		end
		--]]
		empty_table(self.upgr_xml)
		local _st
		for k1,v1 in pairs(self.upgr) do
			_st = xml:InitStatic("workshop:upgrade:pic_upgr_form", nil)
			self.upgr_idx[k1] = xml:InitTextWnd("workshop:upgrade:text_upgr_idx", _st)
			self.upgr_idx[k1]:SetText(tostring(k1))
			self.upgr_xml[k1] = {}
			self.inst_upgr_xml[k1] = {}
			for k2,v2 in pairs(v1) do
				local t = {}
				t.base = xml:InitStatic("workshop:upgrade:upgr_" .. tostring(k2),_st)
				t.b = xml:InitStatic("workshop:upgrade:upgr:back",_st)
				t.itm = xml:InitStatic("workshop:upgrade:upgr:ico",_st)
				t.itm_temp = xml:InitStatic("workshop:upgrade:upgr:ico",_st)
				t.txt = xml:InitTextWnd("workshop:upgrade:upgr:txt",_st)
				t.pic = xml:InitStatic("workshop:upgrade:upgr:pic",_st)
				--t.msk = xml:InitStatic("workshop:upgrade:upgr:mask",_st)
				t.btn = xml:InitCheck("workshop:upgrade:upgr:btn",_st) --Init3tButton
				
				local offset_y = 0
				if ((k2 == 1) and (not self.upgr[k1][2])) or ((k2 == 3) and (not self.upgr[k1][4])) or ((k2 == 5) and (not self.upgr[k1][6])) then
					offset_y = 25
				end
				
				txr_utils.adjust_pos_to_element(t.base, 0, offset_y, t.b, t.itm, t.itm_temp, t.txt, t.pic, t.btn)
				
				t.pic:InitTexture(v2.icon)
				t.pic:SetStretchTexture(true)
				if v2.tool and ini_sys:section_exist(v2.tool) then
					cnt = 0
					if self.upgr_tools[v2.tool] then
						for id,v in pairs(self.upgr_tools[v2.tool]) do
							cnt = cnt + v
						end
					end
					
					txr_utils.set_up_icon(v2.tool, cnt == 0, t.itm_temp, t.itm)
					t.txt:SetText(tostring(cnt))
				end
				
				self.inst_upgr_xml[k1][k2] = false
				self:Register(t.btn,"check_upgrade")
				
				self.upgr_xml[k1][k2] = t
			end
			self.scroll_upgr:AddWindow(_st, true)
		end
	end
end

function workshop_upgrade_ui:EvaluateUpgrades()
	self.step = self.step + 1
	if (self.step > 1) then
		--self.btn_upgrade:Enable(true)
	end
	
	local function check_same_group(gr,idx)
		local tbl = {
			[1] = 2,
			[2] = 1,
			[3] = 4,
			[4] = 3,
			[5] = 6,
			[6] = 5,
		}
		local oth = tbl[idx]
		local sec = self.upgr[gr][oth] and self.upgr[gr][oth].section 
		return not (sec and self.inst_upgr[sec])
	end
	
	local function check_upgr_scheme(gr,idx)
		local tbl = {
			[3] = {1,2},
			[4] = {1,2},
			[5] = {3,4},
			[6] = {3,4},
		}
		local pre = tbl[idx]
		if (not pre) then return true end
		
		local sec_i = self.upgr[gr][pre[1]] and self.upgr[gr][pre[1]].section
		local sec_j = self.upgr[gr][pre[2]] and self.upgr[gr][pre[2]].section
		
		return (sec_i and self.inst_upgr[sec_i]) or (sec_j and self.inst_upgr[sec_j]) or false
	end
	
	local function check_con(con, col)
		local tbl = {
			[1] = 30,
			[2] = 60,
			[3] = 90,
		}
		return tbl[col] < con
	end
	
	local function discharge_tool(tbl)
		if tbl then
			local id = random_key_table(tbl)
			local uses = tbl[id]
			if uses and uses > 0 then
				uses = uses - 1
				self.upgr_tools_pick[#self.upgr_tools_pick + 1] = id
				if uses == 0 then
					tbl[id] = nil
					return 0
				else
					tbl[id] = uses
					return uses
				end
			end
		end
	end
	
	-- Install upgrades
	local last_gr = self.last_upgr[1]
	local last_idx = self.last_upgr[2]
	if last_gr and last_idx then 
		if self.inst_upgr_xml[last_gr][last_idx] then
			self.upgr_xml[last_gr][last_idx].btn:SetCheck(true)
			return
			
		elseif self.upgr[last_gr][last_idx] then
			-- save installed upgrade
			local upgr_sec = self.upgr[last_gr][last_idx].section
			self.inst_upgr[upgr_sec] = true
			self.inst_upgr_xml[last_gr][last_idx] = true
			
			if self.owner.dbg then
				print_ws("~Workshop upgrade UI: DEBUG mode - no discharged items")
			else
				-- reduce main toolkit count
				local num = discharge_tool(self.upgr_tools[self.upgr_toolkit])
				print_ws("~Workshop upgrade UI: discharged item [%s] - remaining: %s", self.upgr_toolkit, num)
				
				-- reduce toolkit count
				local tool = self.upgr[last_gr][last_idx].tool or ""
				num = discharge_tool(self.upgr_tools[tool])
				print_ws("~Workshop upgrade UI: discharged item [%s] - remaining: %s", tool, num)
			end
			
			txr_utils.play_sound("interface\\inv_slot")
			
			SetTip("upgrade_tip_3", nil, nil, nil, true, self.info_text)
			
			if (self.step > 1) then
				self.btn_upgrade:Enable(true)
			end
		end
	end
	
	-- Init main tool ico + num
	local cnt = 0
	local is_main_toolkit = false
	if self.upgr_tools[self.upgr_toolkit] then
		for k,v in pairs(self.upgr_tools[self.upgr_toolkit]) do
			cnt = cnt + v
		end
		is_main_toolkit = cnt > 0
	end
	txr_utils.set_up_icon(self.upgr_toolkit, cnt == 0, self.itm_ico_temp_rq, self.itm_ico_rq)
	local clr = (cnt == 0 and clr_r) or clr_g
	self.itm_num_rq:SetText(clr .. tostring(cnt))
	
	-- Check upgrades, uncheck and disable everything else
	for k1,v1 in pairs(self.upgr_xml) do
		for k2,v2 in pairs(v1) do
			local upgr_sec = self.upgr[k1][k2].section
			if self.inst_upgr[upgr_sec] then
				self.inst_upgr_xml[k1][k2] = true
				v2.btn:SetCheck(true)
			else
				v2.btn:SetCheck(false)
				v2.btn:Enable(false)
			end
			
			-- update tool icon
			local tool = self.upgr[k1][k2].tool -- TODO: find out why some upgrades have no tools
			cnt = 0
			if tool then
				if self.upgr_tools[tool] then
					for k,v in pairs(self.upgr_tools[tool]) do
						cnt = cnt + v
					end
				end
			
				txr_utils.set_up_icon(tool, cnt == 0, v2.itm_temp, v2.itm)
				clr = (cnt == 0 and clr_r) or clr_g
				v2.txt:SetText(clr .. tostring(cnt))
			end
		end
	end
	
	-- Enable possible upgrades
	local ps = false
	empty_table(self.upgr_flags)
	for k1,v1 in pairs(self.upgr_xml) do
		self.upgr_flags[k1] = {}
		for k2,v2 in pairs(v1) do
			local tool = self.upgr[k1][k2].tool
			local col = mc(k2/2)
			local con = math.ceil(100*(self.object:condition()))
			
			local t = {}
			t[1] = is_main_toolkit
			t[2] = tool and self.upgr_tools[tool] and (size_table(self.upgr_tools[tool]) > 0)
			--t[3] = check_con(con, col)
			t[3] = self.toolkits_state[col]
			t[4] = check_same_group(k1,k2)
			t[5] = check_upgr_scheme(k1,k2)
			if tool and t[1] and t[2] and t[3] and t[4] and t[5] then
				--v2.btn:SetCheck(false)
				v2.btn:Enable(true)
				ps = true
			end
			
			-- No need for flags if upgrade is already installed
			if (v2.btn:GetCheck() == true) then
				t = {}
			end
			
			self.upgr_flags[k1][k2] = t
			--alun_utils.print_table(self.upgr_flags)
		end
	end
	
	if is_main_toolkit then
		SetTip("upgrade_tip_1", "upgrade_warning_2", "upgrade_solution_2", nil, ps, self.info_text)
	else
		SetTip("upgrade_tip_1", "upgrade_warning_1", "upgrade_solution_1", self.upgr_toolkit, false, self.info_text)
	end
end


function workshop_upgrade_ui:OnButton_cancel()
	self.owner:OnButton_cancel()
end

function workshop_upgrade_ui:OnButton_upgrade()
	if self.object and (self.step > 1) then
		local obj = self.object
		local id = self.object:id()
		local sec = self.object:section()
		local con = self.object:condition()
		local se_obj = alife_object(id)
		
		-- Special case for binoculars
		local is_wep = IsWeapon(obj) and true or false
		if (ini_sys:r_string_ex(sec,"class") == "WP_BINOC") then
			is_wep = true
		end
		
		if obj and se_obj then
			local a_name
			local result_details = {}
			local get_ammo = {}
			local with_scope = nil
			local data = is_wep and stpk_utils.get_weapon_data(se_obj) or stpk_utils.get_item_data(se_obj)
			local delay = txr_actor_effects.is_animations_on() and 42 or 0
			
			-- Collect attachments for weapons
			if is_wep then
				with_scope = txr_utils.has_scope(sec)
				if with_scope then
					with_scope = string.format('_%s', txr_utils.has_scope(sec))
					table.insert(result_details, with_scope:sub(2))
					sec = sec:gsub(with_scope, "")
				end	
				if (obj:weapon_scope_status() == 2) and (rx_utils.addon_attached(obj,"sc")) then
					local scope_section = rx_utils.read_from_ini2(nil,sec,"scopes_sect","string",nil)
					local scope = rx_utils.read_from_ini2(nil,scope_section,"scope_name","string",nil)
					table.insert(result_details, scope)
				end
				if (obj:weapon_silencer_status() == 2) and (rx_utils.addon_attached(obj,"sl")) then
					local sil = rx_utils.read_from_ini2(nil,sec,"silencer_name","string",nil)
					table.insert(result_details, sil)
				end	
				if (obj:weapon_grenadelauncher_status() == 2) and (rx_utils.addon_attached(obj,"gl")) then
					local gl = rx_utils.read_from_ini2(nil,sec,"grenade_launcher_name","string",nil)
					table.insert(result_details, gl)
				end
				
				-- Unload mag and get ammo
				obj:unload_magazine(true)
				
				--[[ Collect remaining ammo
				if data.ammo_elapsed and data.ammo_elapsed > 0 then
					local ammos = alun_utils.parse_list(ini_sys, sec, "ammo_class")
					get_ammo = { data.ammo_elapsed, ammos[data.ammo_type+1] }
				end
				--]]
			end
			
			-- Sort upgrades
			k2t_table(self.inst_upgr)
			local sort_tbl = {}
			for i=1,#upg_tbl do
				for ii=1,#self.inst_upgr do
					if sf(self.inst_upgr[ii],upg_tbl[i]) then
						sort_tbl[#sort_tbl+1] = self.inst_upgr[ii]
						break
					end
				end
			end
			
			-- Apply upgrades (Upgrades and condition)
			alife():release(se_obj, true)
			
			local se_obju = alife():create(sec, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID, false)
			local id_u = se_obju.id
			local data_u = is_wep and stpk_utils.get_weapon_data(se_obju) or stpk_utils.get_item_data(se_obju)
			data_u.upgrades = sort_tbl
			data_u.condition = con
			
			for i=1,#data_u.upgrades do
				print_ws("- workshop_upgrade_ui:OnButton_upgrade() | installed upgrade (%s) for [%s]", data_u.upgrades[i], sec)
			end
			
			if is_wep then
				stpk_utils.set_weapon_data(data_u,se_obju)
			else
				stpk_utils.set_item_data(data_u,se_obju)
			end
			alife():register(se_obju)
			
			-- Save parts states
			txr_condition.copy_parts_con(id, id_u)
			txr_condition.clear_parts_con(id)
			
			-- Empty ammo of the new weapon object
			if is_wep then
				CreateTimeEvent(0, "delay_empty_weapon", 1, empty_ammo, id_u)
			end
			
			-- Give weapon parts and ammo back to player
			local sim = alife()
			for _, k in ipairs(result_details) do
				sim:create(k, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID)
			end

			--[[
			if get_ammo and get_ammo[1] and get_ammo[2] then
				create_ammo(get_ammo[2], db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID, get_ammo[1])
			end
			--]]
			
			-- Discharge tools
			for i=1,#self.upgr_tools_pick do
				local t_obj = level.object_by_id(self.upgr_tools_pick[i])
				if t_obj then
					itms_manager.discharge(t_obj)
				end
			end
			
			-- Effect
			if self.owner.dbg then
			
			else
				txr_actor_effects.play_item_fx("craft_dummy")
			end
			
			-- Clear cached ammo types for ammo wheel, cause player might change weapon calibre so this will force updating types
			ui_wheel_ammo.clear_cache()
		
			self:OnButton_cancel()
		else
			printf("! ui_workshop | object with id (%s) is not found!", id)
		end
	end
end


function workshop_upgrade_ui:OnKeyboard(dik, keyboard_action)
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
			if dik == DIK_keys.DIK_ESCAPE then
				self:OnButton_cancel()
			end
		end
	end
	return res
end



--######################################################################################################################
--#															4. CRAFT													#
--######################################################################################################################

class "workshop_craft_ui" (CUIScriptWnd)

function workshop_craft_ui:__init(xml, owner, x, y, toolkits_state) super(xml, owner, x, y, toolkits_state)
	self.owner = owner
	self.xml = xml
	self.toolkits_state = toolkits_state or {}
	
	self.last_index = nil -- little trick to get clicked item from inv
	self.last_type = nil
	self.selected_index = nil
	
	-- Table of all craft recipes
	self.recipes = {}
	self.recipes_type = {}
	-- self.recipes_type[indx] = title
	-- self.recipes[indx][num]["section"] = x_morphine
	-- self.recipes[indx][num]["recipe"] = recipe_drug_3
	-- self.recipes[indx][num][1] = {salicidic_acid,1}
	-- self.recipes[indx][num][2] = {drug_booster,4}
	-- self.recipes[indx][num][3] = {e_syringe,2}
	
	-- Showing
	self.recipes_items = {}
	self.inv = {}
	self.inv_recipes = {}
	
	-- Craft objects
	self.craft_item = {}
	self.craft_item_remain = {}
	self.craft_allow = {}
	self.craft_item_r = nil
	self.craft_allow_r = nil
	
	-- Collect unlocked/locked recipes items
	local guide = ui_pda_encyclopedia_tab.get_ui()
	local locked_notes = guide.locked_notes
	local unlocked_notes = dxr_statistics.actor_notes
	for recipe,_ in pairs(itms_manager.itms_recipe) do
		local w = ini_sys:r_float_ex(recipe,"inv_grid_width")
		local h = ini_sys:r_float_ex(recipe,"inv_grid_height")
		local state = false
		if (not locked_notes["encyclopedia__notes_" .. recipe]) and (unlocked_notes["encyclopedia__notes_" .. recipe]) then
			state = true
		end
		self.recipes_items[recipe] = { state = state , w = w , h = h }
	end
	
	self:InitControls(x, y)
	self:InitCallBacks()
end

function workshop_craft_ui:__finalize()
end


function workshop_craft_ui:InitControls(x, y)
	local xml = self.xml	
	
	self:SetWndPos(vector2():set(x,y))
	self:SetAutoDelete(true)

	-- Base
	xml:InitStatic("workshop:craft:cap_menu", self)
	xml:InitStatic("workshop:craft:cap_list", self)
	xml:InitStatic("workshop:craft:cap_recipes", self)
	xml:InitStatic("workshop:craft:pic_menu_b", self)
	xml:InitStatic("workshop:craft:pic_recipe_b", self)
	xml:InitStatic("workshop:craft:pic_inv_b", self)
	
	self.btn_back = xml:Init3tButton("workshop:craft:btn_back", self)
	self:Register(self.btn_back, "button_cancel")
	self.btn_back:Show(false)
	
	self.btn_craft = xml:Init3tButton("workshop:craft:btn_craft", self)
	self:Register(self.btn_craft, "button_craft")
	self.btn_craft:Enable(false)
	
	self.info_text = xml:InitTextWnd("workshop:text_info" , self)
	
	-- Components
	self.cap_components = xml:InitStatic("workshop:craft:cap_components", self)
	self.itm_line = {}
	self.itm_line_c = {}
	self.itm_b = {}
	self.itm_name = {}
	self.itm_num = {}
	self.itm_ico = {}
	self.itm_ico_temp = {}
	for i=1,4 do
		self.itm_line[i] = xml:InitStatic("workshop:craft:pic_c_line_" .. tostring(i) , self)
		self.itm_b[i] = xml:InitStatic("workshop:craft:pic_item_" .. tostring(i) .. "_b" , self)
		self.itm_name[i] = xml:InitTextWnd("workshop:craft:text_item_" .. tostring(i) .. "_name" , self)
		self.itm_num[i] = xml:InitTextWnd("workshop:craft:text_item_" .. tostring(i) .. "_num" , self)
		self.itm_ico[i] = xml:InitStatic("workshop:craft:pic_item_" .. tostring(i) , self)
		self.itm_ico_temp[i] = xml:InitStatic("workshop:craft:pic_item_" .. tostring(i) , self)
		if i > 1 then
			self.itm_line_c[i] = xml:InitStatic("workshop:craft:pic_c_line_" .. tostring(i-1) .. "_" .. tostring(i) , self)
		end
	end
	
	-- Result
	self.itm_line_r1 = xml:InitStatic("workshop:craft:pic_c_line_r1" , self)
	--self.itm_line_r2 = xml:InitStatic("workshop:craft:pic_c_line_r2" , self)
	self.itm_line_r3 = xml:InitStatic("workshop:craft:pic_c_line_r3" , self)
	
	self.itm_b_r = xml:InitStatic("workshop:craft:pic_item_r_b" , self)
	self.itm_name_r = xml:InitTextWnd("workshop:craft:text_item_r_name" , self)
	self.itm_num_r = xml:InitTextWnd("workshop:craft:text_item_r_num" , self)
	self.itm_ico_r = xml:InitStatic("workshop:craft:pic_item_r" , self)
	self.itm_ico_temp_r = xml:InitStatic("workshop:craft:pic_item_r" , self)
	self.cap_r = xml:InitStatic("workshop:craft:cap_result", self)
	
	self.itm_name_t = xml:InitTextWnd("workshop:craft:text_item_t_name" , self)
	self.itm_b_t = xml:InitStatic("workshop:craft:pic_item_t_b" , self)
	self.itm_ico_t = xml:InitStatic("workshop:craft:pic_item_t" , self)
	self.itm_ico_temp_t = xml:InitStatic("workshop:craft:pic_item_t" , self)
	
	
	-- List
	self.list_menu = xml:InitListBox("workshop:craft:list_menu",self)
	self.list_menu:ShowSelectedItem(true)
	self.list_menu:Show(true)
	self:Register(self.list_menu, "list_menu")
	
	-- Scrolls
	self.scroll_inv = xml:InitScrollView("workshop:craft:scrollbar_inv", self)
	self.scroll_recipe = xml:InitScrollView("workshop:craft:scrollbar_recipe", self)
	
	-- Hint Window
	self.hint_wnd = xml:InitFrame("hint_wnd:background",self)
	self.hint_wnd:SetAutoDelete(false)
	self.hint_wnd_text = xml:InitTextWnd("hint_wnd:text",self.hint_wnd)
	self.hint_wnd:Show(false)
	
	-- Message Window 
	self.msg_wnd = xml:InitFrame("hint_wnd:background",self)
	self.msg_wnd:SetAutoDelete(false)
	self.msg_wnd_text = xml:InitTextWnd("hint_wnd:text",self.msg_wnd)
	self.msg_wnd_text:SetTextAlignment(2)
	
	self.msg_wnd:Show(false)
	self.msg_wnd:SetColor(GetARGB(255,0,0,0))
	
	self:LoadRecipes()
	self:InitInventory_RecipesItems()
	
	self:ShowComponents(false)
end

function workshop_craft_ui:InitCallBacks()
	self:AddCallback("button_cancel",		ui_events.BUTTON_CLICKED,         self.OnButton_cancel,			self)
	self:AddCallback("button_craft",		ui_events.BUTTON_CLICKED,         self.OnButton_craft,			self)

	self:AddCallback("btn_item",			ui_events.BUTTON_CLICKED,         self.OnButton_item,			self)
	self:AddCallback("list_menu", 			ui_events.LIST_ITEM_CLICKED, 	  self.OnMenuSelected, 			self)
end

function workshop_craft_ui:Update()
	CUIScriptWnd.Update(self)
	
	-- Warning messages timer 
	if (self.msg_wnd_timer and time_global() > self.msg_wnd_timer) then 
		self.msg_wnd_timer = nil
		self.msg_wnd:Show(false)
	end
	
	if self.last_type and self.recipes[self.last_type] then
		for k,v in pairs(self.recipes[self.last_type]) do 
			if (self.inv[k] and self.inv[k].btn and self.inv[k].btn:IsCursorOverWindow()) then
				local name = ui_item.get_sec_name(v.sec)
				local desc = ui_item.get_sec_desc(v.sec)
				local str = "%c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc
				self:SetHint(str)
				self.last_index = k
				return
			end
		end
		
		local item = self.last_type and self.last_index and self.recipes[self.last_type] and self.recipes[self.last_type][self.selected_index]
		if item then
			for i=1,4 do 
				if self.itm_ico[i] and self.itm_ico[i]:IsCursorOverWindow() then
					local name = ui_item.get_sec_name(item[i][1])
					local desc = ui_item.get_sec_desc(item[i][1])
					local str = "%c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc
					self:SetHint(str)
					return
				end
			end
		end
	end
	
	for k,v in pairs(self.inv_recipes) do 
		if (self.inv_recipes[k].ico and self.inv_recipes[k].ico:IsCursorOverWindow()) then
			local name = ui_item.get_sec_name(k)
			local desc = ui_item.get_sec_desc(k)
			local str = "%c[0,200,200,200]" .. name .. "\\n \\n%c[0,140,140,140]" .. desc
			self:SetHint(str)
			return
		end
	end

	self.hint_wnd:Show(false)
end 

function workshop_craft_ui:SetMsg(text,tmr)
	if (text == "") then 
		return 
	end
	self.msg_wnd:Show(true)
	self.msg_wnd_text:SetText(text)
	self.msg_wnd_text:AdjustHeightToText()
	self.msg_wnd_text:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+10))
	self.msg_wnd_text:SetWndPos(vector2():set(0,20))
	
	self.msg_wnd:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+44))
	self.msg_wnd:SetWndPos(vector2():set(0,80))

	self.msg_wnd_timer = time_global() + 1000*tmr
end

function workshop_craft_ui:SetHint(text,pos)
	if (text == "") then
		return
	end
	self.hint_wnd:Show(true)
	self.hint_wnd_text:SetText(text)
	self.hint_wnd_text:AdjustHeightToText()
	self.hint_wnd:SetWndSize(vector2():set(self.hint_wnd:GetWidth(),self.hint_wnd_text:GetHeight()+44))
	
	pos = pos or GetCursorPosition()
	pos.y = pos.y - self.hint_wnd:GetHeight()
	pos.x = pos.x - self.hint_wnd:GetWidth()
	self.hint_wnd:SetWndPos(pos)
	
	FitInRect(self.hint_wnd,Frect():set(0,0,1024,768),0,100)
end


function workshop_craft_ui:LoadRecipes()
	-- Less parts on achievement
	local ach = 0
	if (dxr_achievements.has_achievement("artificer_eagerness")) then
		ach = 1
	end

	local ind = 1
	while ini_craft:section_exist(tostring(ind)) do
		local ind_str = tostring(ind)
		local n = ini_craft:line_count(ind_str) or 0
		self.recipes[ind] = {}
		for i=0, n-1 do
			local result, id, value = ini_craft:r_line(ind_str , i , "", "")
			if (id == "title") then
				self.recipes_type[ind] = value
			end
			id = string.sub(id,3)
			if ini_sys:section_exist(id) then
				local t = alun_utils.str_explode(value,",")
				if (#t == 6) or (#t == 8) or (#t == 10) then
					local x = #self.recipes[ind] + 1
					self.recipes[ind][x] = {}
					self.recipes[ind][x].sec = id
					self.recipes[ind][x].tool = tonumber(t[1]) or 1
					self.recipes[ind][x].rsp = t[2]
					if t[3] and t[4] then -- support item 1
						if ini_sys:section_exist(tostring(t[3])) then
							local amt = tonumber(t[4])
							self.recipes[ind][x][1] = {tostring(t[3]), (amt > 4) and (amt - ach) or amt}
						else
							printf("! Workshop UI craft | componenet section [%s] not found for [%s] recipe!", tostring(t[3]), id)
						end
					end
					if t[5] and t[6] then -- support item 2
						if ini_sys:section_exist(tostring(t[5])) then
							local amt = tonumber(t[6])
							self.recipes[ind][x][2] = {tostring(t[5]), (amt > 4) and (amt - ach) or amt}
						else
							printf("! workshop_craft_ui:LoadRecipes() | componenet section [%s] not found for [%s] recipe!", tostring(t[5]), id)
						end
					end
					if t[7] and t[8] then -- support item 3
						if ini_sys:section_exist(tostring(t[7])) then
							local amt = tonumber(t[8])
							self.recipes[ind][x][3] = {tostring(t[7]), (amt > 4) and (amt - ach) or amt}
						else
							printf("! workshop_craft_ui:LoadRecipes() | componenet section [%s] not found for [%s] recipe!", tostring(t[7]), id)
						end
					end
					if t[9] and t[10] then -- support item 4
						if ini_sys:section_exist(tostring(t[9])) then
							local amt = tonumber(t[10])
							self.recipes[ind][x][4] = {tostring(t[9]), (amt > 4) and (amt - ach) or amt}
						else
							printf("! workshop_craft_ui:LoadRecipes() | componenet section [%s] not found for [%s] recipe!", tostring(t[9]), id)
						end
					end
				end
			elseif (id ~= "tle") then
				printf("! workshop_craft_ui:LoadRecipes() | section [%s] not found!",id)
			end
		end
		
		ind = ind + 1
	end
	
	--alun_utils.print_table(self.recipes)
	--alun_utils.print_table(self.recipes_type)
	
	for i=1,#self.recipes_type do
		local _itm = list_element(i, self.recipes_type[i])
		self.list_menu:AddExistingItem(_itm)
	end
	
	SetTip("craft_intro", nil, nil, nil, true, self.info_text)
end

function workshop_craft_ui:OnMenuSelected()
	local xml = self.xml
	
	self.btn_craft:Enable(false)
	
	txr_utils.play_sound("interface\\inv_page")
	
	local menu = self.list_menu:GetSelectedItem()
	if (not menu) then return end
	self.last_type = menu.idx
	
	local function count_grids_num(t)
		local cnt = 0
		for _,v in pairs(t) do
			local w = ini_sys:r_float_ex(v.sec,"inv_grid_width")
			local h = ini_sys:r_float_ex(v.sec,"inv_grid_height")
			cnt = cnt + (w * h)
		end
		return cnt
	end
	
	empty_table(self.inv)
	self.scroll_inv:Clear()
	local _st = xml:InitStatic("workshop:craft:pic_inv_form", nil)
	
	local grid = xml:InitStatic("inv_grid", nil)
	local grid_w = grid:GetWidth()
	local grid_h = grid:GetHeight()
	local tot_grid_w = math.floor(_st:GetWidth() / grid_w)
	local tot_grid_h = math.floor(_st:GetHeight() / grid_h)
	local tot_grid_num = math.max( count_grids_num(self.recipes[self.last_type]) , (tot_grid_w * tot_grid_h))
	local tot_grid_ind = {}
	for i=1,tot_grid_num do
		local row = mc(i/tot_grid_w)
		tot_grid_ind[row] = tot_grid_ind[row] or {}
		tot_grid_ind[row][#tot_grid_ind[row] + 1] = true
	end
	--printf("-Workshop UI | total grid number: %s , grid coloumns: %s , one grid width: %s , one grid height: %s", tot_grid_num, tot_grid_w, grid_w, grid_h)
	local idx = 0
	for k,v in pairs(self.recipes[self.last_type]) do
		--printf("-Workshop UI | scan item (%s) [%s]", k, v.sec)
		local w = ini_sys:r_float_ex(v.sec,"inv_grid_width")
		local h = ini_sys:r_float_ex(v.sec,"inv_grid_height")
		idx = idx + 1
		self.inv[idx] = {}
		self.inv[idx].ico_tmp = xml:InitStatic("inv_grid", _st)
		self.inv[idx].btn = xml:Init3tButton("inv_btn_" .. tostring(w) .. "_" .. tostring(h), _st)
		self.inv[idx].ico = xml:InitStatic("inv_grid", _st)
		self.inv[idx].ico_s = xml:InitStatic("inv_grid", _st)
		
		tot_grid_h = txr_utils.set_grid_element(
			{ id = "_" , sec = v.sec , g_w = grid_w , g_h = grid_h , w = w , h = h , g_row = tot_grid_w },
			tot_grid_ind,
			self.inv[idx].btn, self.inv[idx].ico, self.inv[idx].ico_s, self.inv[idx].ico_tmp
		)
		self:Register(self.inv[idx].btn, "btn_item")
		txr_utils.set_up_icon(v.sec, (self.recipes_items[v.rsp] and not self.recipes_items[v.rsp].state), self.inv[idx].ico_tmp, self.inv[idx].ico, self.inv[idx].ico_s)
	end
	
	_st:SetWndSize(vector2():set(_st:GetWidth(),tot_grid_h * grid_h))
	self.scroll_inv:AddWindow(_st, true)
	_st:SetAutoDelete(false)
	
	self:ShowComponents(false)
	
	SetTip("craft_tip_1", nil, nil, nil, true, self.info_text)
end

function workshop_craft_ui:InitInventory_RecipesItems()
	local xml = self.xml

	local function count_grids_num(t)
		local cnt = 0
		for _,v in pairs(t) do
			cnt = cnt + (v.w * v.h)
		end
		return cnt
	end
	
	empty_table(self.inv_recipes)
	self.scroll_recipe:Clear()
	local _st = xml:InitStatic("workshop:craft:pic_recipe_form", nil)
	
	local grid = xml:InitStatic("inv_grid", nil)
	local grid_w = grid:GetWidth()
	local grid_h = grid:GetHeight()
	local tot_grid_w = math.floor(_st:GetWidth() / grid_w)
	local tot_grid_h = math.floor(_st:GetHeight() / grid_h)
	local tot_grid_num = math.max( count_grids_num(self.recipes_items) , (tot_grid_w * tot_grid_h))
	local tot_grid_ind = {}
	for i=1,tot_grid_num do
		local row = mc(i/tot_grid_w)
		tot_grid_ind[row] = tot_grid_ind[row] or {}
		tot_grid_ind[row][#tot_grid_ind[row] + 1] = true
	end

	for k,v in pairs(self.recipes_items) do
		self.inv_recipes[k] = {}
		self.inv_recipes[k].ico_tmp = xml:InitStatic("inv_grid", _st)
		self.inv_recipes[k].ico = xml:InitStatic("inv_grid", _st)
		self.inv_recipes[k].ico_s = xml:InitStatic("inv_grid", _st)
		
		tot_grid_h = txr_utils.set_grid_element(
			{ id = "_" , sec = k , g_w = grid_w , g_h = grid_h , w = v.w , h = v.h , g_row = tot_grid_w },
			tot_grid_ind,
			self.inv_recipes[k].ico, self.inv_recipes[k].ico_s, self.inv_recipes[k].ico_tmp
		)
		txr_utils.set_up_icon(k, (not v.state), self.inv_recipes[k].ico_tmp, self.inv_recipes[k].ico, self.inv_recipes[k].ico_s)
	end
	
	_st:SetWndSize(vector2():set(_st:GetWidth(),tot_grid_h * grid_h))
	self.scroll_recipe:AddWindow(_st, true)
	_st:SetAutoDelete(false)
end

function workshop_craft_ui:OnButton_item()
	local item = self.last_type and self.last_index and self.recipes[self.last_type] and self.recipes[self.last_type][self.last_index]
	if (not item) then
		return
	end
	
	if (self.recipes_items[item.rsp] and (not self.recipes_items[item.rsp].state)) then
		SetTip(nil, "craft_warning_2", "craft_solution_2", item.sec, false, self.info_text)
		self:ShowComponents(false)
		return
	end
	
	txr_utils.play_sound("interface\\items\\inv_items_cloth_" .. tostring(math.random(2,3)))
	
	-- Reset
	self.craft_item = {}
	self.craft_item_remain = {}
	self.craft_allow = {}
	self.craft_item_r = nil
	self.craft_allow_r = nil
	self.selected_index = self.last_index

	for i=1,4 do
		local sh = false
		if item[i] then
			sh = true
		end
		self.itm_line[i]:Show(sh)
		self.itm_b[i]:Show(sh)
		self.itm_name[i]:Show(sh)
		self.itm_num[i]:Show(sh)
		self.itm_ico[i]:Show(sh)
		if i > 1 then
			self.itm_line_c[i]:Show(sh)
		end
		
		if item[i] then
			self:UpdateItem(i, item[i][1], item[i][2], false, nil, nil)
		end
	end
	
	self.cap_components:Show(true)
	self.itm_line_r1:Show(true)
	--self.itm_line_r2:Show(true)
	self.itm_line_r3:Show(true)
	
	self.itm_b_r:Show(true)
	self.itm_name_r:Show(true)
	self.itm_num_r:Show(true)
	self.itm_ico_r:Show(true)
	self.cap_r:Show(true)
	
	self.itm_name_t:Show(true)
	self.itm_b_t:Show(true)
	self.itm_ico_t:Show(true)
	self.itm_ico_temp_t:Show(true)
	
	self:UpdateItem(nil, item.sec, 1, true, item.tool, workshop_toolkits[item.tool])
end

function workshop_craft_ui:UpdateItem (n, sec, amount, result, toolkit_idx, toolkit_sec)

	-- Text (Amount)
	local amt = amount
	local box = 1
	if itms_manager.is_ammo(nil, sec) then
		box = ini_sys:r_float_ex(sec,"box_size")
		amt = box * amount
	end
	--self.itm_num[n]:SetText("x" .. tostring(amt))
	
	-- Text (Name)
	local parts_id = {}
	local counter = 0
	local name = ui_item.get_sec_name(sec)
	
	
	if (not result) then
		-- Reset
		self.craft_item[n] = {}
		self.craft_item_remain[n] = {}
		self.craft_allow[n] = false
		
		self.itm_name[n]:SetText(name)
		self.itm_num[n]:SetTextColor(GetARGB(250, 255, 50, 50)) --GetARGB(200, 255, 50, 20)
	
		-- Collect valid items
		local function search(temp, item)
			if (item:section() == sec) and (not parts_id[item:id()]) then
				local cnt = itms_manager.is_multi_use(item) and item:get_remaining_uses() or 1
				parts_id[item:id()] = cnt
			end
		end
		db.actor:iterate_inventory(search,nil)
		
		-- Check and Allow/Prevent
		local count = 0
		for _,cnt in pairs(parts_id) do
			count = count + cnt
		end
		
		-- Ammo boxes
		if itms_manager.is_ammo(nil, sec) then -- ammo
			local full_ammo = 0
			local full_ammo_txt = 0
			for id,_ in pairs(parts_id) do
				local ammo = level.object_by_id(id)
				if ammo then
					local size = ammo:ammo_get_count()
					local box_size = ammo:ammo_box_size()
					full_ammo_txt = full_ammo_txt + size
					if (size >= box_size) then
						full_ammo = full_ammo + 1
					else
						parts_id[id] = nil
					end
					if (full_ammo >= amount) then
						self.itm_num[n]:SetTextColor(GetARGB(200, 50, 255, 50))
						self.craft_allow[n] = true
					end
				end
			end
			self.itm_num[n]:SetText(tostring(full_ammo_txt) .. "/" .. tostring(amt))
			
		-- Normal items
		else
			if (count >= amount) then
				self.itm_num[n]:SetTextColor(GetARGB(200, 50, 255, 50))
				self.craft_allow[n] = true
			end
			self.itm_num[n]:SetText(tostring(count) .. "/" .. tostring(amt))
		end
		
		-- Store items id
		count = 0
		for id,cnt in pairs(parts_id) do
			count = count + cnt

			-- to delete
			if (count <= amount) then
				self.craft_item[n][#self.craft_item[n] + 1] = id
			end
			
			if count == amount then
				break
			end
			
			-- to discharge
			if count > amount then
				self.craft_item_remain[n] = { id = id , cnt = (count - amount) }
				break
			end
		end
		
		txr_utils.set_up_icon(sec, (not self.craft_allow[n]), self.itm_ico_temp[n], self.itm_ico[n])
		
	-- if its the result item
	else
		local stop = false
		local toolkit_name = ui_item.get_sec_name(toolkit_sec)
		
		for i=1,4 do
			if self.craft_allow[i] == false then
				stop = true
				SetTip(nil, "craft_warning_4", "craft_solution_4", nil, false, self.info_text)
				break
			end
		end
		if not (stop) then 
			if (not self.toolkits_state[toolkit_idx]) then
				stop = true
				SetTip(nil, "craft_warning_3", "craft_solution_3", toolkit_sec, false, self.info_text)
			end
		end
		
		if (not stop) then
			self.craft_allow_r = true
			self.itm_num_r:SetTextColor(GetARGB(250, 50, 255, 50))
			SetTip("craft_tip_5", nil, nil, sec, true, self.info_text)
			self.btn_craft:Enable(true)
		else
			self.itm_num_r:SetTextColor(GetARGB(250, 255, 50, 50))
			self.btn_craft:Enable(false)
		end
		
		if itms_manager.is_ammo(nil, sec) then
			amount = box
		end
		self.craft_item_r = {sec , amount}
		
		-- Repesent finale uses if its mulit-use item
		local amount_txt = tostring(amount) or ""
		if itms_manager.is_multi_use(nil,sec) then
			local uses = ini_sys:r_float_ex(sec,"max_uses") or amount
			amount_txt = tostring(uses) or ""
		end
		
		self.itm_name_r:SetText(name)
		self.itm_num_r:SetText(amount_txt)
		txr_utils.set_up_icon(sec, (not self.craft_allow_r), self.itm_ico_temp_r, self.itm_ico_r)
		
		self.itm_name_t:SetText(toolkit_name)
		txr_utils.set_up_icon(toolkit_sec, (not self.toolkits_state[toolkit_idx]), self.itm_ico_temp_t, self.itm_ico_t)
	end
end

function workshop_craft_ui:ShowComponents(sh)
	for i=1,4 do
		self.itm_line[i]:Show(sh)
		self.itm_b[i]:Show(sh)
		self.itm_name[i]:Show(sh)
		self.itm_num[i]:Show(sh)
		self.itm_ico[i]:Show(sh)
		if i > 1 then
			self.itm_line_c[i]:Show(sh)
		end
	end
	
	self.cap_components:Show(sh)
	self.itm_line_r1:Show(sh)
	--self.itm_line_r2:Show(sh)
	self.itm_line_r3:Show(sh)
	
	self.itm_b_r:Show(sh)
	self.itm_name_r:Show(sh)
	self.itm_num_r:Show(sh)
	self.itm_ico_r:Show(sh)
	self.cap_r:Show(sh)
	
	self.itm_name_t:Show(sh)
	self.itm_b_t:Show(sh)
	self.itm_ico_t:Show(sh)
	self.itm_ico_temp_t:Show(sh)
end


function workshop_craft_ui:OnButton_cancel()
	self.owner:OnButton_cancel()
end

function workshop_craft_ui:OnButton_craft()
	if (not self.craft_allow_r) then 
		return 
	end
	
	local sim = alife()
	
	-- Remove supportive items
	for i=1,#self.craft_item do
		-- Release
		if #self.craft_item[i] > 0 then
			for j=1,#self.craft_item[i] do
				local se_obj = alife_object(self.craft_item[i][j])
				if se_obj then
					print_ws("- workshop_craft_ui:OnButton_craft() | item %s (%s) - release", i, self.craft_item[i][j])
					sim:release(se_obj,true)
				end
			end
		end
		
		-- Discharge
		local id_r = self.craft_item_remain[i].id
		if id_r then
			local obj_itm = level.object_by_id(id_r)
			local cnt = self.craft_item_remain[i].cnt
			if obj_itm and cnt then
				print_ws("- workshop_craft_ui:OnButton_craft() | discharge item (%s) [%s] %s times", id_r, obj_itm:section(), cnt)
				for k=1,cnt do
					itms_manager.discharge(obj_itm)
				end
			end
		end
	end
	
	-- Craft
	if (itms_manager.is_ammo(nil, self.craft_item_r[1])) then
		create_ammo(self.craft_item_r[1], db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID, self.craft_item_r[2])
	else
		for i = 1, self.craft_item_r[2] do
			sim:create(self.craft_item_r[1], db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID)
		end
	end
	
	-- Increase Statistic
	dxr_statistics.increment_statistic("items_crafted")
	
	-- Effect
	txr_actor_effects.play_item_fx("craft_dummy")
	
	self:OnButton_cancel()
end


function workshop_craft_ui:OnKeyboard(dik, keyboard_action)
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
			if dik == DIK_keys.DIK_ESCAPE then
				self:OnButton_cancel()
			end
		end
	end
	return res
end


--=======================================< Utilies >=======================================--
function empty_ammo(wpn_id)
	local obj = level.object_by_id(wpn_id)
	if obj then
		print_ws("workshop_upgrade_ui:OnButton_upgrade() | empty weapons (%s)", wpn_id)
		obj:unload_magazine()
	end
	return true
end

function SetTip(tip, warning, solution, sec, pass, XMLtxt)
	local str = "" -- "• "
	local name = sec and ui_item.get_sec_name(sec) or ""
	if tip and pass then
		local str_tip = game.translate_string("st_ui_workshop_info_" .. tip)
		str = str .. clr_dark .. strformat(str_tip, name)
	else
		if warning then
			local str_warning = game.translate_string("st_ui_workshop_info_" .. warning)
			str = str .. clr_o .. strformat(str_warning, name)
		end
		if solution then
			local str_solution = game.translate_string("st_ui_workshop_info_" .. solution)
			str = str .. clr_dark .. " \\n" .. strformat(str_solution, name)
		end
	end
	XMLtxt:SetText(str)
end

function AdjustCon(sec_part, con, num, is_outfit)
	if (not is_outfit) then
		return con
	end
	
	local delta = 100/num
	local x_min = 0.4
	local x_max = (100 - delta * x_min)/(delta * (num-1))
	if string.find(sec_part,"prt_o_fabrics_") then
		return con * x_min
	end
	return con * x_max
end

function print_ws(fmt,...)
	if enable_debug then printf(fmt,...) end
end